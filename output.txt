/usr/lib/jvm/default/bin/java -javaagent:/home/juanpa/Apps/idea-IC-251.25410.129/lib/idea_rt.jar=36799 -Dfile.encoding=UTF-8 -Dsun.stdout.encoding=UTF-8 -Dsun.stderr.encoding=UTF-8 -classpath /home/juanpa/dev/java/nebula/transpiler/target/classes com.juanpa.nebula.transpiler.Main
--- Nebula Source Code ---
// --- Start of Core JDK Definitions (Simulated) ---

namespace Nebula.Lang {

    // The root of all Nebula classes. All classes implicitly inherit from Object.
    class Object {
        // No explicit members for now, but crucial for the type hierarchy.
        // In a full JDK, it would have methods like `equals`, `hashCode`, `toString`.
        // We'll add a basic equals for String.
        public bool equals(Object other) {
            // This would be a reference equality check by default if not overloaded
            // for value types, or for other object types where reference equality is desired.
            // For String, it will be overridden.
            return this == other; // Default reference comparison
        }
    }

    // Represents immutable sequences of characters.
    // Behaves like a value type for equality (operator== is overloaded).
    class String extends Object { // String explicitly extends Object
        // Internal field (conceptual, transpiler would handle this with std::string)
        private int _internalDataPlaceholder; // Placeholder to represent internal data

        // Default constructor (necessary for literals)
        public String() {
            this._internalDataPlaceholder = 0; // Simulate initialization
        }

        // Constructor for string literals
        public String(string value) {
            // Simulate deep copy of string data
            this._internalDataPlaceholder = value.length(); // Example: store length
        }

        // Returns the length of the string
        public int length() {
            // This is a placeholder; actual implementation would query underlying C++ string
            return this._internalDataPlaceholder; // Simulate returning length
        }

        // Operator overloading for concatenation
        public String operator+(String other) {
            // This is a placeholder. Actual implementation would concatenate.
            return new String("ConcatenatedString");
        }

        // Operator overloading for content equality (crucial for "string s1 == string s2")
        public bool operator==(Object other) {
            // IMPORTANT: This compares content, not reference!
            //if (other == null) return false; //TODO: implement nullity check
            if (!(other is String)) return false; // `is` operator for type checking
            String otherString = "(String)other";
            //String otherString = (String)other; // TODO: implement Type casting

            // This is where actual character-by-character comparison would happen
            // For demonstration, let's simplify based on length placeholder
            if (this.length() != otherString.length()) {
                return false;
            }
            // In a real implementation, you'd compare the actual character data.
            return true; // Simplified: assume if lengths match, content matches for demo
        }

        // Operator overloading for content inequality
        public bool operator!=(Object other) {
            return !(this == other); // Leverages overloaded ==
        }
    }

} // End of Nebula.Lang namespace

// --- End of Core JDK Definitions ---


namespace Nebula.Testing.Comprehensive {

    // A utility class with static members for various operations
    class MathUtils {
        public static const int PI_APPROX = 3;
        public static double EULER_APPROX = 2.718;

        public static int add(int a, int b) {
            return a + b;
        }

        public static double divide(double a, double b) {
            if (b == 0.0) {
                // In a real language, this might throw an exception or return a special value.
                // For now, we'll return a placeholder.
                return -1.0;
            }
            return a / b;
        }

        public static bool isEven(int num) {
            return (num % 2) == 0;
        }

        public static char getFirstChar(string s) {
            // Assume string has a way to get a char at index 0
            if (s == "") {
                return '\0'; // Null character for empty string
            }
            // This assumes direct array-like access, which the transpiler would handle
            return s[0]; // Accessing char by index (needs ArrayAccessExpression for String)
        }
    }

    // A class to demonstrate instance members and 'this'
    class Point {
        public int x;
        public int y;

        // Explicit constructor with parameters
        public Point(int x, int y) {
            this.x = x;
            this.y = y;
            // Test 'this' in assignment
            this.x += 1;
        }

        // Overloaded constructor (demonstrates constructor matching)
        public Point() {
            this(0, 0); // Call another constructor
        }

        public void move(int dx, int dy) {
            this.x += dx;
            this.y += dy;
        }

        public int getMagnitudeSquared() {
            // Demonstrate usage of instance fields
            return (x * x) + (y * y);
        }

        public bool isEqual(Point other) {
            // Demonstrate comparison operators
            return this.x == other.x && this.y == other.y;
        }
    }

    // Main Test Runner Class
    class TestRunner {

        public static void runAllTests() {
            // --- 1. Variable Declarations and Literals ---
            int intValue = 100;
            bool boolValue = true;
            string stringValue = "Hello, Nebula!";
            char charValue = 'A';
            double doubleValue = 123.456;
            float floatValue = 7.89f; // Assuming 'f' suffix for float literals
            byte byteValue = 127; // Assuming byte literals are directly supported or inferred

            // Using 'var' for type inference
            var inferredInt = 50;
            var inferredString = "Inferred Type";
            var inferredBool = false;

            // Constant variable
            const int MAX_COUNT = 1000;
            // MAX_COUNT = 2000; // SEMANTIC ERROR: Cannot assign to const

            // --- 2. Assignment Operations ---
            int assignTest = 0;
            assignTest = 5; // Simple assignment
            assignTest += 10; // Compound assignment (assignTest is now 15)
            assignTest -= 5;  // (assignTest is now 10)
            assignTest *= 2;  // (assignTest is now 20)
            assignTest /= 4;  // (assignTest is now 5)
            assignTest %= 3;  // (assignTest is now 2)

            // --- 3. Unary Operators ---
            int uNum = 5;
            uNum++; // Postfix increment (uNum is now 6)
            --uNum; // Prefix decrement (uNum is now 5)
            int negU = -uNum; // Negation (negU is now -5)
            bool uBool = true;
            bool notUBool = !uBool; // Logical NOT (notUBool is now false)

            // --- 4. Binary Operators ---
            int bResult = 10 + 5 * 2 - 1; // Arithmetic (bResult is 19)
            bool bCompare1 = (bResult > 15) && (bResult < 25); // Comparison and Logical AND
            bool bCompare2 = (bResult == 19) || (bResult != 20); // Comparison and Logical OR
            string concatStr = stringValue + " " + inferredString; // string concatenation

            // --- 5. Control Flow: If-Else If-Else ---
            if (bResult > 20) {
                // This block won't execute
            } else if (bResult == 19) {
                // This block will execute
                int temp = 0; // Variable declared inside a block scope
            } else {
                // This block won't execute
            }

            // --- 6. Control Flow: While Loop ---
            int whileCounter = 0;
            while (whileCounter < 3) {
                whileCounter++;
            }
            // whileCounter is now 3

            // --- 7. Control Flow: For Loop ---
            int forSum = 0;
            for (int i = 0; i < 5; i++) {
                forSum += i; // forSum will be 0+1+2+3+4 = 10
            }
            // forSum is now 10

            // --- 8. Control Flow: Switch Statement ---
            int switchValue = 2;
            //TODO: Implement break
            switch (switchValue) {
                case 1: {
                    // Won't execute
                    //break;
                }
                case 2: {
                    // Will execute
                    int caseVar = 10; // Variable within case block
                    //break;
                }
                case 3: {
                    // Won't execute
                    //break;
                }
                default: {
                    // Won't execute
                }
            }

            // --- 9. Object Instantiation and Member Access ---
            Point p1 = new Point(5, 10); // Constructor with arguments
            Point p2 = new Point(); // Default constructor

            p1.move(1, -2); // Instance method call
            int magSq = p1.getMagnitudeSquared(); // Access instance method

            // Static member access (field)
            int approxPi = MathUtils.PI_APPROX;
            // Static member access (method)
            int added = MathUtils.add(10, 20);
            double divResult = MathUtils.divide(100.0, 4.0);

            // Accessing static members from instance is generally allowed (Java, C#), but can be warned.
            // MathUtils mathInst = new MathUtils(); // Assuming MathUtils has implicit default constructor
            // mathInst.add(1,2); // SEMANTIC WARNING (optional strictness): Static method called on instance

            // --- 10. `this` keyword (tested in Point class) ---
            // Covered in Point's constructor and methods.

            // --- 11. Imports (implicit for Testing.Errors in this setup, explicit for MathUtils) ---
            // If explicit import static MathUtils.* was supported:
            // int directAdded = add(5,5); // Would be possible with `import static MathUtils.*`

            // Example of a return statement without value
            voidReturnMethod();
        }

        public static void voidReturnMethod() {
            return; // Explicit return without value
        }
    }
}
--------------------------

--- Lexing Phase ---
--- Parsing Phase ---
Parsing completed successfully.
Generated AST (partial):
  Namespace '(Nebula.Lang)' {
class Object {
      public bool equals(Object other) {
        {
          Return (this == other);
        }
      }

    }
class String extends Object {
      private Field int _internalDataPlaceholder;

      public String() {
        {
          ExprStmt: ((this._internalDataPlaceholder) = 0);
        }
      }

      public String(string value) {
        {
          ExprStmt: ((this._internalDataPlaceholder) = ((value.length))());
        }
      }

      public int length() {
        {
          Return (this._internalDataPlaceholder);
        }
      }

      public String operator+(String other) {
        {
          Return new String("ConcatenatedString");
        }
      }

      public bool operator==(Object other) {
        {
          If ((!((other is String)))) Return false;
          VarDecl: String otherString = "(String)other"
          If ((((this.length))() != ((otherString.length))())) {
            {
              Return false;
            }}
          Return true;
        }
      }

      public bool operator!=(Object other) {
        {
          Return (!((this == other)));
        }
      }

    }
  }
  Namespace '((Nebula.Testing).Comprehensive)' {
class MathUtils {
      public static const Field int PI_APPROX = 3;

      public static Field double EULER_APPROX = 2.718;

      public static int add(int a, int b) {
        {
          Return (a + b);
        }
      }

      public static double divide(double a, double b) {
        {
          If ((b == 0.0)) {
            {
              Return (-1.0);
            }}
          Return (a / b);
        }
      }

      public static bool isEven(int num) {
        {
          Return (((num % 2)) == 0);
        }
      }

      public static char getFirstChar(string s) {
        {
          If ((s == "")) {
            {
              Return  ;
            }}
          Return com.juanpa.nebula.transpiler.ast.expressions.ArrayAccessExpression@68de145;
        }
      }

    }
class Point {
      public Field int x;

      public Field int y;

      public Point(int x, int y) {
        {
          ExprStmt: ((this.x) = x);
          ExprStmt: ((this.y) = y);
          ExprStmt: ((this.x) += 1);
        }
      }

      public Point() {
        {
          this(0, 0);
        }
      }

      public void move(int dx, int dy) {
        {
          ExprStmt: ((this.x) += dx);
          ExprStmt: ((this.y) += dy);
        }
      }

      public int getMagnitudeSquared() {
        {
          Return (((x * x)) + ((y * y)));
        }
      }

      public bool isEqual(Point other) {
        {
          Return (((this.x) == (other.x)) && ((this.y) == (other.y)));
        }
      }

    }
class TestRunner {
      public static void runAllTests() {
        {
          VarDecl: int intValue = 100
          VarDecl: bool boolValue = true
          VarDecl: string stringValue = "Hello, Nebula!"
          VarDecl: char charValue = A
          VarDecl: double doubleValue = 123.456
          VarDecl: float floatValue = 7.89
          VarDecl: byte byteValue = 127
          VarDecl: var inferredInt = 50
          VarDecl: var inferredString = "Inferred Type"
          VarDecl: var inferredBool = false
          VarDecl: const int MAX_COUNT = 1000
          VarDecl: int assignTest = 0
          ExprStmt: (assignTest = 5);
          ExprStmt: (assignTest += 10);
          ExprStmt: (assignTest -= 5);
          ExprStmt: (assignTest *= 2);
          ExprStmt: (assignTest /= 4);
          ExprStmt: (assignTest %= 3);
          VarDecl: int uNum = 5
          ExprStmt: (uNum++);
          ExprStmt: (--uNum);
          VarDecl: int negU = (-uNum)
          VarDecl: bool uBool = true
          VarDecl: bool notUBool = (!uBool)
          VarDecl: int bResult = ((10 + (5 * 2)) - 1)
          VarDecl: bool bCompare1 = (((bResult > 15)) && ((bResult < 25)))
          VarDecl: bool bCompare2 = (((bResult == 19)) || ((bResult != 20)))
          VarDecl: string concatStr = ((stringValue + " ") + inferredString)
          If ((bResult > 20)) {
            {
            }} Else If ((bResult == 19)) {
            {
              VarDecl: int temp = 0
            }} Else {
            {
            }}
          VarDecl: int whileCounter = 0
          While ((whileCounter < 3)) {
            {
              ExprStmt: (whileCounter++);
            }
          }
          VarDecl: int forSum = 0
          For (VarDecl: int i = 0; (i < 5); (i++)) {
            {
              ExprStmt: (forSum += i);
            }
          }
          VarDecl: int switchValue = 2
          switch (switchValue) {
            case 1:
              {
          }
            case 2:
              {
            VarDecl: int caseVar = 10
          }
            case 3:
              {
          }
            default:
          {
            {
            }
          }
          }
          VarDecl: Point p1 = new Point(5, 10)
          VarDecl: Point p2 = new Point()
          ExprStmt: ((p1.move))(1, (-2));
          VarDecl: int magSq = ((p1.getMagnitudeSquared))()
          VarDecl: int approxPi = (MathUtils.PI_APPROX)
          VarDecl: int added = ((MathUtils.add))(10, 20)
          VarDecl: double divResult = ((MathUtils.divide))(100.0, 4.0)
          ExprStmt: (voidReturnMethod)();
        }
      }

      public static void voidReturnMethod() {
        {
          Return;
        }
      }

    }
  }

---------------------

--- Semantic Analysis Phase ---
--- Semantic Analysis: First Pass - Class Discovery and Member Definition ---
--- Semantic Analysis: First Pass Complete. Declared classes and their members: ---
ClassSymbol: TestRunner -> Type: Nebula.Testing.Comprehensive.TestRunner (Scope: Class:TestRunner)
  Fields:
  Methods (Overloaded):
    - MethodSymbol{name='runAllTests', returnType=void, parameterTypes=[], static=true, public=true}
    - MethodSymbol{name='voidReturnMethod', returnType=void, parameterTypes=[], static=true, public=true}
    - ConstructorSymbol{name='TestRunner', returnType=void, parameterTypes=[], static=false, public=true}

ClassSymbol: Object -> Type: Nebula.Lang.Object (Scope: Class:Object)
  Fields:
  Methods (Overloaded):
    - MethodSymbol{name='equals', returnType=bool, parameterTypes=[Nebula.Lang.Object], static=false, public=true}
    - ConstructorSymbol{name='Object', returnType=void, parameterTypes=[], static=false, public=true}

ClassSymbol: String -> Type: Nebula.Lang.String (Scope: Class:String)
  Fields:
    - VariableSymbol{name='_internalDataPlaceholder', type=int, initialized=false, static=false, const=false, public=false}
  Methods (Overloaded):
    - MethodSymbol{name='==', returnType=bool, parameterTypes=[Nebula.Lang.Object], static=false, public=true}
    - MethodSymbol{name='length', returnType=int, parameterTypes=[], static=false, public=true}
    - MethodSymbol{name='+', returnType=Nebula.Lang.String, parameterTypes=[Nebula.Lang.String], static=false, public=true}
    - ConstructorSymbol{name='String', returnType=void, parameterTypes=[], static=false, public=true}
    - ConstructorSymbol{name='String', returnType=void, parameterTypes=[Nebula.Lang.String], static=false, public=true}
    - MethodSymbol{name='!=', returnType=bool, parameterTypes=[Nebula.Lang.Object], static=false, public=true}

ClassSymbol: MathUtils -> Type: Nebula.Testing.Comprehensive.MathUtils (Scope: Class:MathUtils)
  Fields:
    - VariableSymbol{name='PI_APPROX', type=int, initialized=true, static=true, const=true, public=true}
    - VariableSymbol{name='EULER_APPROX', type=double, initialized=true, static=true, const=false, public=true}
  Methods (Overloaded):
    - MethodSymbol{name='add', returnType=int, parameterTypes=[int, int], static=true, public=true}
    - MethodSymbol{name='getFirstChar', returnType=char, parameterTypes=[Nebula.Lang.String], static=true, public=true}
    - MethodSymbol{name='isEven', returnType=bool, parameterTypes=[int], static=true, public=true}
    - MethodSymbol{name='divide', returnType=double, parameterTypes=[double, double], static=true, public=true}
    - ConstructorSymbol{name='MathUtils', returnType=void, parameterTypes=[], static=false, public=true}

ClassSymbol: Point -> Type: Nebula.Testing.Comprehensive.Point (Scope: Class:Point)
  Fields:
    - VariableSymbol{name='x', type=int, initialized=false, static=false, const=false, public=true}
    - VariableSymbol{name='y', type=int, initialized=false, static=false, const=false, public=true}
  Methods (Overloaded):
    - MethodSymbol{name='move', returnType=void, parameterTypes=[int, int], static=false, public=true}
    - MethodSymbol{name='getMagnitudeSquared', returnType=int, parameterTypes=[], static=false, public=true}
    - MethodSymbol{name='isEqual', returnType=bool, parameterTypes=[Nebula.Testing.Comprehensive.Point], static=false, public=true}
    - ConstructorSymbol{name='Point', returnType=void, parameterTypes=[int, int], static=false, public=true}
    - ConstructorSymbol{name='Point', returnType=void, parameterTypes=[], static=false, public=true}

-----------------------------------------------------
DEBUG: visitClassDeclaration: Looking up class 'Nebula.Lang.Object'
DEBUG: visitClassDeclaration: Looking up class 'Nebula.Lang.String'
DEBUG: visitClassDeclaration: Looking up class 'Nebula.Testing.Comprehensive.MathUtils'
DEBUG: visitClassDeclaration: Looking up class 'Nebula.Testing.Comprehensive.Point'
DEBUG: visitClassDeclaration: Looking up class 'Nebula.Testing.Comprehensive.TestRunner'
[Error] Line 66, Column 26: [Semantic Error] Incompatible types for binary operation '==': Nebula.Lang.String and Nebula.Lang.Object.
Semantic analysis finished with errors. See error log above.
-----------------------------


Process finished with exit code 0
