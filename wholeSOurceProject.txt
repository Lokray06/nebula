--- Directory Tree for: transpiler ---
Located at: /home/juanpa/dev/java/nebula/transpiler/src/main/java/com/juanpa/nebula/transpiler

/home/juanpa/dev/java/nebula/transpiler/src/main/java/com/juanpa/nebula/transpiler
├── ast
│   ├── ASTNode.java
│   ├── ASTVisitor.java
│   ├── declarations
│   │   ├── ClassDeclaration.java
│   │   ├── ConstructorDeclaration.java
│   │   ├── FieldDeclaration.java
│   │   ├── ImportDirective.java
│   │   ├── MethodDeclaration.java
│   │   └── NamespaceDeclaration.java
│   ├── expressions
│   │   ├── ArrayAccessExpression.java
│   │   ├── AssignmentExpression.java
│   │   ├── BinaryExpression.java
│   │   ├── CallExpression.java
│   │   ├── DotExpression.java
│   │   ├── Expression.java
│   │   ├── GroupingExpression.java
│   │   ├── IdentifierExpression.java
│   │   ├── IsExpression.java
│   │   ├── LiteralExpression.java
│   │   ├── NewExpression.java
│   │   ├── PostfixUnaryExpression.java
│   │   ├── ThisExpression.java
│   │   └── UnaryExpression.java
│   ├── Program.java
│   └── statements
│       ├── BlockStatement.java
│       ├── ConstructorChainingCallStatement.java
│       ├── ExpressionStatement.java
│       ├── ForStatement.java
│       ├── IfStatement.java
│       ├── ReturnStatement.java
│       ├── Statement.java
│       ├── SwitchCase.java
│       ├── SwitchStatement.java
│       ├── VariableDeclarationStatement.java
│       └── WhileStatement.java
├── codegen
│   └── CppGenerator.java
├── lexer
│   ├── NebulaLexer.java
│   ├── Token.java
│   └── TokenType.java
├── Main.java
├── parser
│   └── NebulaParser.java
├── semantics
│   ├── ArrayType.java
│   ├── ClassSymbol.java
│   ├── ClassType.java
│   ├── ErrorType.java
│   ├── MethodSymbol.java
│   ├── NamespaceType.java
│   ├── NullType.java
│   ├── PrimitiveType.java
│   ├── SemanticAnalyzer.java
│   ├── Symbol.java
│   ├── SymbolTable.java
│   ├── Type.java
│   └── VariableSymbol.java
└── util
    └── ErrorReporter.java

10 directories, 54 files

ommited SemanticAnalizer.java

semantics/ErrorType.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/semantics/ErrorType.java
package com.juanpa.nebula.transpiler.semantics;

/**
 * Represents an error type, used to propagate type checking errors.
 * This is a singleton.
 */
public class ErrorType extends Type
{
	public static final ErrorType INSTANCE = new ErrorType();

	private ErrorType()
	{
		super("error");
	}

	@Override
	public boolean isAssignableFrom(Type other)
	{
		// An error type can be assigned from anything (to allow error propagation),
		// but nothing can be assigned to it unless it's also an error.
		return other instanceof ErrorType;
	}

	@Override
	public boolean isCompatibleWith(Type other)
	{
		// An error type is compatible only with other error types for operations.
		return other instanceof ErrorType;
	}

	@Override
	public boolean equals(Object o)
	{
		return this == o; // Singleton equality
	}

	@Override
	public int hashCode()
	{
		return super.hashCode();
	}
}
semantics/PrimitiveType.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/semantics/PrimitiveType.java

package com.juanpa.nebula.transpiler.semantics;

/**
 * Represents primitive types in the Nebula language (e.g., int, bool, String, double).
 * Implements type compatibility rules for these basic types.
 */
public class PrimitiveType extends Type
{
	// Pre-defined singletons for common primitive types
	public static final PrimitiveType INT = new PrimitiveType("int");
	public static final PrimitiveType BOOL = new PrimitiveType("bool");
	// Note: String is treated as a class type for C# like behavior, not a primitive here.
	// This PrimitiveType.STRING instance might be a remnant or used for conceptual compatibility.
	// For "string" keyword, it will map to Nebula.Lang.String ClassSymbol.
	public static final PrimitiveType STRING = new PrimitiveType("String"); // This will be phased out for ClassType "nebula.core.String"
	public static final PrimitiveType DOUBLE = new PrimitiveType("double");
	public static final PrimitiveType FLOAT = new PrimitiveType("float");
	public static final PrimitiveType BYTE = new PrimitiveType("byte");
	public static final PrimitiveType CHAR = new PrimitiveType("char");
	public static final PrimitiveType VOID = new PrimitiveType("void"); // For method return types

	private PrimitiveType(String name)
	{
		super(name);
	}

	@Override
	public boolean isAssignableFrom(Type other)
	{
		if(this.equals(other))
		{
			return true; // Same type is always assignable
		}

		// Allow implicit numeric conversions (widening conversions)
		if(this.equals(DOUBLE) && (other.equals(INT) || other.equals(FLOAT) || other.equals(BYTE) || other.equals(CHAR)))
		{
			return true;
		}
		if(this.equals(FLOAT) && (other.equals(INT) || other.equals(BYTE) || other.equals(CHAR)))
		{
			return true;
		}
		if(this.equals(INT) && (other.equals(BYTE) || other.equals(CHAR)))
		{
			return true;
		}
		// Explicit char to byte or vice versa is not typically implicit, but for simplicity:
		// If char is 16-bit unsigned and byte is 8-bit signed, this is a narrowing conversion.
		// Assuming char and byte are both 8-bit for simplicity, or char is compatible with int.
		if(this.equals(CHAR) && other.equals(BYTE))
		{ // Byte -> Char (potential data loss if char is unsigned and byte is signed)
			return true;
		}
		if(this.equals(BYTE) && other.equals(CHAR))
		{ // Char -> Byte (definite data loss potential)
			return true;
		}

		// Null can be assigned to any ClassType or ArrayType, not PrimitiveType.
		if(other instanceof NullType)
		{
			return false;
		}

		// String is generally not implicitly convertible from other primitives directly here.
		// 'bool' is not convertible from other primitives.
		// 'void' is only for return types, not assignable.
		return false;
	}

	/**
	 * Checks if this primitive type is assignable to the target type.
	 * Implements widening conversions for primitive types (e.g., int -> double).
	 *
	 * @param targetType The type to which this type is being assigned.
	 * @return True if this primitive type can be assigned to targetType, false otherwise.
	 */
	@Override
	public boolean isAssignableTo(Type targetType)
	{
		if(super.isAssignableTo(targetType))
			return true; // Handles self-assignment and ErrorType

		if(!(targetType instanceof PrimitiveType))
			return false; // Can only assign primitives to primitives (or special cases like String from char[])

		PrimitiveType target = (PrimitiveType) targetType;

		// Widening conversions (example rules, adjust as per Nebula spec)
		if(this == INT)
		{
			return target == FLOAT || target == DOUBLE || target == BYTE; // int can widen to float, double, byte
		}
		if(this == BYTE)
		{
			return target == INT || target == FLOAT || target == DOUBLE; // byte can widen to int, float, double
		}
		if(this == FLOAT)
		{
			return target == DOUBLE; // float can widen to double
		}
		// bool, char, void usually have no implicit widening conversions to other primitives
		return false;
	}

	@Override
	public boolean isCompatibleWith(Type other)
	{
		if(this.equals(other))
		{
			return true;
		}

		// Numeric types are generally compatible for arithmetic operations
		if(this.isNumeric() && other.isNumeric())
		{
			return true;
		}

		// Boolean types are compatible only with other booleans for logical ops
		if(this.equals(BOOL) && other.equals(BOOL))
		{
			return true;
		}

		// Void is never compatible for operations
		return false;
	}

	@Override
	public boolean isNumeric()
	{
		return this.equals(INT) || this.equals(FLOAT) || this.equals(DOUBLE) || this.equals(BYTE) || this.equals(CHAR);
	}

	// This is a singleton pattern, but without preventing instantiation
	// to allow for potential future extensions where PrimitiveType might need
	// slight variations or custom creation (though not recommended for basic primitives).
	// A more strict singleton would have private constructor and public static final instances only.
}
semantics/Symbol.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/semantics/Symbol.java

package com.juanpa.nebula.transpiler.semantics;

import com.juanpa.nebula.transpiler.lexer.Token;

/**
 * Abstract base class for all symbols in the symbol table.
 * A symbol represents a declared entity in the program (e.g., variable, method, class).
 */
public abstract class Symbol
{
	private final String name;
	private final Type type;
	private final Token declarationToken; // The token where this symbol was declared
	protected boolean isPublic; // Add this field for visibility status

	/**
	 * Constructor for a Symbol.
	 *
	 * @param name             The name of the symbol.
	 * @param type             The type of the symbol.
	 * @param declarationToken The token representing the declaration of this symbol.
	 * @param isPublic         True if the symbol is public, false otherwise.
	 */
	public Symbol(String name, Type type, Token declarationToken, boolean isPublic)
	{
		this.name = name;
		this.type = type;
		this.declarationToken = declarationToken;
		this.isPublic = isPublic;
	}

	/**
	 * Constructor for a Symbol (defaults to non-public).
	 *
	 * @param name             The name of the symbol.
	 * @param type             The type of the symbol.
	 * @param declarationToken The token representing the declaration of this symbol.
	 */
	public Symbol(String name, Type type, Token declarationToken)
	{
		this(name, type, declarationToken, false); // Default to non-public
	}

	public String getName()
	{
		return name;
	}

	public Type getType()
	{
		return type;
	}

	public Token getDeclarationToken()
	{
		return declarationToken;
	}

	/**
	 * Indicates whether this symbol represents a static member (field or method).
	 *
	 * @return True if the symbol is static, false otherwise.
	 */
	public abstract boolean isStatic();

	/**
	 * Indicates whether this symbol is public.
	 *
	 * @return True if the symbol is public, false otherwise.
	 */
	public boolean isPublic()
	{
		return isPublic;
	}

	/**
	 * Sets the public status of this symbol.
	 *
	 * @param aPublic True to mark the symbol as public, false otherwise.
	 */
	public void setPublic(boolean aPublic)
	{
		isPublic = aPublic;
	}

	@Override
	public String toString()
	{
		return "Symbol{" + "name='" + name + '\'' + ", type=" + type + ", line=" + declarationToken.getLine() + ", public=" + isPublic + '}';
	}
}

semantics/SymbolTable.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/semantics/SymbolTable.java

package com.juanpa.nebula.transpiler.semantics;

import com.juanpa.nebula.transpiler.lexer.Token;

import java.util.HashMap;
import java.util.Map;

/**
 * Represents a symbol table for a specific scope in the Nebula language.
 * It maps identifier names to their corresponding Symbol objects.
 * Symbol tables form a tree structure, allowing for hierarchical scope management.
 */
public class SymbolTable
{
	final Map<String, Symbol> symbols;
	private final SymbolTable enclosingScope; // Reference to the parent scope
	private final String scopeName; // For debugging/identification (e.g., "global", "method:main", "block:if")
	private Type currentScopeType; // Added to track the Type of the scope (e.g., ClassType for class scope)

	public SymbolTable(SymbolTable enclosingScope, String scopeName)
	{
		this.symbols = new HashMap<>();
		this.enclosingScope = enclosingScope;
		this.scopeName = scopeName;
	}

	/**
	 * Defines a new symbol in the current scope.
	 *
	 * @param symbol The symbol to define.
	 * @throws IllegalArgumentException if a symbol with the same name already exists in this scope.
	 */
	public void define(Symbol symbol)
	{
		if(symbols.containsKey(symbol.getName()))
		{
			// This check should ideally be handled by a specific error in SemanticAnalyzer,
			// but for now, a runtime exception indicates a semantic error during definition.
			throw new IllegalArgumentException("Symbol '" + symbol.getName() + "' already defined in scope '" + scopeName + "'.");
		}
		symbols.put(symbol.getName(), symbol);
	}

	/**
	 * Looks up a symbol, starting from the current scope and moving up to enclosing scopes.
	 *
	 * @param name The name of the symbol to look up.
	 * @return The found Symbol, or null if not found in any enclosing scope.
	 */
	public Symbol resolve(String name)
	{
		Symbol symbol = symbols.get(name);
		if(symbol != null)
		{
			return symbol;
		}
		// If not found in current scope, try to resolve in the enclosing scope
		if(enclosingScope != null)
		{
			return enclosingScope.resolve(name);
		}
		return null; // Symbol not found
	}

	/**
	 * Looks up a symbol only in the current scope.
	 *
	 * @param name The name of the symbol to look up.
	 * @return The found Symbol, or null if not found in this scope.
	 */
	public Symbol resolveCurrentScope(String name)
	{
		return symbols.get(name);
	}

	public SymbolTable getEnclosingScope()
	{
		return enclosingScope;
	}

	public String getScopeName()
	{
		return scopeName;
	}

	// Getter and Setter for currentScopeType
	public Type getCurrentScopeType()
	{
		return currentScopeType;
	}

	public void setCurrentScopeType(Type currentScopeType)
	{
		this.currentScopeType = currentScopeType;
	}

	@Override
	public String toString()
	{
		StringBuilder sb = new StringBuilder();
		sb.append("Scope '").append(scopeName).append("':\n");
		for(Map.Entry<String, Symbol> entry : symbols.entrySet())
		{
			sb.append("  ").append(entry.getValue()).append("\n");
		}
		return sb.toString();
	}
}
semantics/NullType.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/semantics/NullType.java
package com.juanpa.nebula.transpiler.semantics;

/**
 * Represents the type of the `null` literal.
 * `null` can be assigned to any reference type (ClassType, ArrayType).
 */
public class NullType extends Type
{
	public static final NullType INSTANCE = new NullType();

	private NullType()
	{
		super("null");
	}

	/**
	 * Checks if this `NullType` is assignable TO the target type.
	 * `null` can be assigned to any ClassType or ArrayType.
	 *
	 * @param targetType The type to which `NullType.INSTANCE` is being assigned.
	 * @return True if `NullType` can be assigned to targetType, false otherwise.
	 */
	@Override
	public boolean isAssignableTo(Type targetType)
	{
		if(super.isAssignableTo(targetType))
			return true; // Handles self-assignment and ErrorType

		// Null can be assigned to any ClassType or ArrayType (reference types)
		return targetType instanceof ClassType || targetType instanceof ArrayType;
	}

	@Override
	public boolean isAssignableFrom(Type other)
	{
		// Null can be assigned to any reference type (ClassType, ArrayType).
		// It cannot be assigned FROM other types, only TO them.
		// This method defines what can be assigned *to* THIS type.
		// So, this method should return false because nothing is assignable FROM NullType,
		// except NullType itself. The check for "assigning null to X" should be
		// `X.isAssignableFrom(NullType.INSTANCE)`.
		return false;
	}

	@Override
	public boolean isCompatibleWith(Type other)
	{
		// Null is not compatible with other types for most operations directly.
		// Its compatibility is defined by assignability to reference types.
		return false;
	}

	@Override
	public boolean equals(Object o)
	{
		return this == o; // Singleton equality
	}

	@Override
	public int hashCode()
	{
		return super.hashCode(); // Consistent with singleton
	}
}
semantics/MethodSymbol.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/semantics/MethodSymbol.java

package com.juanpa.nebula.transpiler.semantics;

import com.juanpa.nebula.transpiler.lexer.Token;

import java.util.Collections;
import java.util.List;

/**
 * Represents a method (or constructor, which is a special type of method) in the symbol table.
 * Stores its name, return type, parameter types, and a reference to its scope.
 */
public class MethodSymbol extends Symbol
{
	private final List<Type> parameterTypes;
	private final SymbolTable methodScope; // The scope associated with this method's body
	private final boolean isStatic; // Indicates if the method is static
	private final boolean isConstructor; // NEW: Flag to explicitly mark if this symbol represents a constructor
	private ClassSymbol ownerClass; // NEW: Reference to the ClassSymbol this method belongs to


	/**
	 * Constructor for a regular MethodSymbol.
	 *
	 * @param name             The name of the method.
	 * @param returnType       The return type of the method.
	 * @param parameterTypes   A list of types for the method's parameters.
	 * @param declarationToken The token where this method was declared.
	 * @param methodScope      The symbol table for the method's local scope.
	 * @param isStatic         True if this is a static method, false otherwise.
	 * @param isPublic         True if this method is public, false otherwise.
	 */
	public MethodSymbol(String name, Type returnType, List<Type> parameterTypes, Token declarationToken, SymbolTable methodScope, boolean isStatic, boolean isPublic)
	{
		super(name, returnType, declarationToken, isPublic);
		this.parameterTypes = Collections.unmodifiableList(parameterTypes);
		this.methodScope = methodScope;
		this.isStatic = isStatic;
		this.isConstructor = false; // Regular methods are not constructors
	}

	/**
	 * Constructor for a MethodSymbol (defaults to non-public if not specified).
	 *
	 * @param name             The name of the method.
	 * @param returnType       The return type of the method.
	 * @param parameterTypes   A list of types for the method's parameters.
	 * @param declarationToken The token where this method was declared.
	 * @param methodScope      The symbol table for the method's local scope.
	 * @param isStatic         True if this is a static method, false otherwise.
	 */
	public MethodSymbol(String name, Type returnType, List<Type> parameterTypes, Token declarationToken, SymbolTable methodScope, boolean isStatic)
	{
		this(name, returnType, parameterTypes, declarationToken, methodScope, isStatic, false);
	}

	/**
	 * Constructor for a ConstructorSymbol (special type of method without explicit return type).
	 * Assumed to have a return type of VOID for internal representation.
	 * Constructors are typically non-static. Their public status is passed explicitly.
	 *
	 * @param name             The name of the constructor (same as class name).
	 * @param parameterTypes   A list of types for the constructor's parameters.
	 * @param declarationToken The token where this constructor was declared.
	 * @param methodScope      The symbol table for the constructor's local scope.
	 * @param isPublic         True if this constructor is public, false otherwise.
	 */
	public MethodSymbol(String name, List<Type> parameterTypes, Token declarationToken, SymbolTable methodScope, boolean isPublic)
	{
		// Constructors are non-static, implicitly return VOID, and are explicitly marked as constructors
		super(name, PrimitiveType.VOID, declarationToken, isPublic);
		this.parameterTypes = Collections.unmodifiableList(parameterTypes);
		this.methodScope = methodScope;
		this.isStatic = false; // Constructors are never static
		this.isConstructor = true; // NEW: Mark as constructor
	}

	/**
	 * Constructor for a ConstructorSymbol (special type of method without explicit return type),
	 * defaults to public.
	 */
	public MethodSymbol(String name, List<Type> parameterTypes, Token declarationToken, SymbolTable methodScope)
	{
		this(name, parameterTypes, declarationToken, methodScope, true); // Default to public
	}

	public ClassSymbol getOwnerClass()
	{
		return ownerClass;
	}

	public void setOwnerClass(ClassSymbol ownerClass)
	{
		this.ownerClass = ownerClass;
	}

	public List<Type> getParameterTypes()
	{
		return parameterTypes;
	}

	public SymbolTable getMethodScope()
	{
		return methodScope;
	}

	@Override
	public boolean isStatic()
	{
		return isStatic;
	}

	public boolean isConstructor()
	{
		return isConstructor;
	}

	/**
	 * Checks if the given actual argument types are compatible with this method's parameter types.
	 *
	 * @param actualArgTypes The list of actual argument types.
	 * @return True if the arguments match this method's signature, false otherwise.
	 */
	public boolean matchesArguments(List<Type> actualArgTypes)
	{
		if(this.parameterTypes.size() != actualArgTypes.size())
		{
			return false;
		}
		for(int i = 0; i < this.parameterTypes.size(); i++)
		{
			Type formal = this.parameterTypes.get(i);
			Type actual = actualArgTypes.get(i);
			// Check type compatibility (actual must be assignable to formal)
			if(actual instanceof ErrorType || formal instanceof ErrorType)
			{
				continue; // Don't block on error types, allow semantic analysis to continue
			}
			if(!actual.isAssignableTo(formal))
			{
				// This method needs to be implemented in your Type hierarchy
				return false;
			}
		}
		return true;
	}

	@Override
	public String toString()
	{
		String methodOrConstructor = isConstructor ? "ConstructorSymbol" : "MethodSymbol";
		return methodOrConstructor + "{" +
				"name='" + getName() + '\'' +
				", returnType=" + getType() +
				", parameterTypes=" + parameterTypes +
				", static=" + isStatic() +
				", public=" + isPublic() +
				'}';
	}
}
semantics/ClassSymbol.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/semantics/ClassSymbol.java
package com.juanpa.nebula.transpiler.semantics;

import com.juanpa.nebula.transpiler.lexer.Token;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class ClassSymbol extends Symbol
{
	private ClassType type;
	private final Token declarationToken;
	private final SymbolTable classScope; // For fields and nested classes/types

	// NEW: Dedicated map to store methods by name, where each name maps to a list of MethodSymbols (for overloading)
	final Map<String, List<MethodSymbol>> methodsByName;


	public ClassSymbol(String name, ClassType type, Token declarationToken, SymbolTable classScope)
	{
		super(name, type, declarationToken, true);
		this.type = type;
		this.declarationToken = declarationToken;
		this.classScope = classScope;
		this.methodsByName = new HashMap<>(); // Initialize
	}

	public ClassType getType()
	{
		return type;
	}

	public void setType(ClassType type)
	{
		this.type = type;
	}

	public Token getDeclarationToken()
	{
		return declarationToken;
	}

	public SymbolTable getClassScope()
	{
		return classScope;
	}


	/**
	 * Defines a method or constructor in this class's scope.
	 * This handles method overloading by storing multiple methods with the same name.
	 *
	 * @param methodSymbol The method or constructor symbol to define.
	 */
	public void defineMethod(MethodSymbol methodSymbol)
	{
		methodsByName.computeIfAbsent(methodSymbol.getName(), k -> new ArrayList<>()).add(methodSymbol);
		// Note: We are NOT adding methods/constructors to `classScope.symbols` directly anymore
		// to avoid the `IllegalArgumentException` for overloaded methods.
		// Fields will still be defined in `classScope.symbols`.
	}

	/**
	 * Resolves a member (field, method, constructor) within this class's scope, including overloading.
	 * This method will be used by SemanticAnalyzer to look up members.
	 *
	 * @param memberName    The name of the member to resolve.
	 * @param argumentTypes The types of arguments (null for fields, empty list for no-arg methods).
	 *                      This is crucial for method/constructor overloading resolution.
	 * @return The resolved Symbol (VariableSymbol, MethodSymbol), or null if not found.
	 */
	public Symbol resolveMember(String memberName, List<Type> argumentTypes)
	{
		// 1. If argumentTypes is null, primarily look for a field.
		//    If argumentTypes is not null, primarily look for a method.

		// Attempt to resolve as a field first (fields are stored in classScope's direct map)
		// A field is identified by name, NOT by argument types.
		Symbol field = classScope.resolveCurrentScope(memberName);
		if(field instanceof VariableSymbol)
		{
			// If this call is specifically looking for a field (argumentTypes == null)
			// OR if it's a method call but no matching method is found later, it might default to the field.
			// However, for strictness, if arguments are provided, it's *expected* to be a method.
			if(argumentTypes == null)
			{ // This is how `visitDotExpression` should call it for fields
				return field;
			}
		}

		// Try to resolve as a method/constructor (from the dedicated methodsByName map)
		List<MethodSymbol> candidates = methodsByName.get(memberName);
		if(candidates != null && argumentTypes != null) // Only attempt method resolution if argumentTypes are provided
		{
			MethodSymbol bestMatch = null;
			for(MethodSymbol candidate : candidates)
			{
				if(candidate.matchesArguments(argumentTypes)) // Use the matchesArguments helper
				{
					bestMatch = candidate;
					// For simplicity, we take the first match. For full specificity, need to rank overloads.
					break;
				}
			}
			if(bestMatch != null)
			{
				return bestMatch;
			}
		}

		// 3. (Optional) Check inherited members if inheritance is implemented.
		// If currentClass has a superClassType, resolve member in superclass.
		if(type.getSuperClassType() instanceof ClassType)
		{
			ClassSymbol superClassSymbol = ((ClassType) type.getSuperClassType()).getClassSymbol();
			if(superClassSymbol != null)
			{
				return superClassSymbol.resolveMember(memberName, argumentTypes); // Recursive call
			}
		}

		return null; // Member not found
	}

	// Overload for cases where no arguments are involved (e.g., field access).
// This should explicitly look for a field.
	public Symbol resolveMember(String memberName)
	{
		return resolveMember(memberName, null); // Call the main method indicating 'no arguments' (i.e., look for field)
	}


	@Override
	public boolean isStatic()
	{
		return true; // Classes themselves are considered static entities
	}

	@Override
	public String toString()
	{
		StringBuilder sb = new StringBuilder("ClassSymbol: " + getName() + " -> Type: " + (type != null ? type.getName() : "null") + " (Scope: " + classScope.getScopeName() + ")\n");
		sb.append("  Fields:\n");
		classScope.symbols.values().stream()
				.filter(s -> s instanceof VariableSymbol)
				.forEach(s -> sb.append("    - ").append(s).append("\n"));
		sb.append("  Methods (Overloaded):\n");
		methodsByName.values().stream()
				.flatMap(List::stream) // Flatten the list of lists of methods
				.forEach(m -> sb.append("    - ").append(m).append("\n"));
		return sb.toString();
	}

	public String getFqn()
	{
		return type.getFqn();
	}
}
semantics/Type.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/semantics/Type.java

package com.juanpa.nebula.transpiler.semantics;

/**
 * Abstract base class for all types in the Nebula language.
 * This includes primitive types (int, bool, String, etc.) and user-defined class types.
 */
public abstract class Type
{
	protected String name;

	public Type(String name)
	{
		this.name = name;
	}

	public String getName()
	{
		return name;
	}

	/**
	 * Checks if this type is assignable from another type.
	 * This method should be overridden by concrete type implementations to define
	 * type compatibility rules.
	 *
	 * @param other The other type to check for assignability.
	 * @return True if 'other' can be assigned to this type, false otherwise.
	 */
	public abstract boolean isAssignableFrom(Type other);

	/**
	 * Checks if this type is compatible with another type for binary operations.
	 * This method should be overridden by concrete type implementations.
	 *
	 * @param other The other type to check for binary operation compatibility.
	 * @return True if compatible, false otherwise.
	 */
	public abstract boolean isCompatibleWith(Type other);

	/**
	 * Checks if this type is a numeric type.
	 *
	 * @return True if numeric, false otherwise.
	 */
	public boolean isNumeric()
	{
		// Default implementation: most types are not numeric unless specified.
		// PrimitiveType will override this.
		return false;
	}

	/**
	 * Returns the wider of two numeric types.
	 * This should ideally be a static helper or a method on a numeric type utility.
	 * Placed here for now to satisfy `SemanticAnalyzer`'s `Type.getWiderNumericType` calls.
	 *
	 * @param type1 The first type.
	 * @param type2 The second type.
	 * @return The wider numeric type, or ErrorType.INSTANCE if not compatible.
	 */
	public static Type getWiderNumericType(Type type1, Type type2)
	{
		if(!type1.isNumeric() || !type2.isNumeric())
		{
			return ErrorType.INSTANCE; // Not numeric, or one is not numeric
		}

		// Simple hierarchy: byte -> char -> int -> float -> double
		// For more complex hierarchy, you might use an enum for type ranks.

		if(type1.equals(PrimitiveType.DOUBLE) || type2.equals(PrimitiveType.DOUBLE))
			return PrimitiveType.DOUBLE;
		if(type1.equals(PrimitiveType.FLOAT) || type2.equals(PrimitiveType.FLOAT))
			return PrimitiveType.FLOAT;
		if(type1.equals(PrimitiveType.INT) || type2.equals(PrimitiveType.INT))
			return PrimitiveType.INT;
		if(type1.equals(PrimitiveType.CHAR) || type2.equals(PrimitiveType.CHAR))
			return PrimitiveType.CHAR;
		if(type1.equals(PrimitiveType.BYTE) || type2.equals(PrimitiveType.BYTE))
			return PrimitiveType.BYTE;

		// Should not be reached if both are numeric and handled above
		return ErrorType.INSTANCE;
	}

	/**
	 * Checks if two types are comparable (e.g., for ==, != operators).
	 * This should ideally be a static helper.
	 *
	 * @param type1 The first type.
	 * @param type2 The second type.
	 * @return True if comparable, false otherwise.
	 */
	public static boolean isComparable(Type type1, Type type2)
	{
		if(type1.equals(type2))
			return true; // Same type is always comparable

		// Null is comparable with any reference type
		if(type1 instanceof NullType && (type2 instanceof ClassType || type2 instanceof ArrayType))
			return true;
		if(type2 instanceof NullType && (type1 instanceof ClassType || type1 instanceof ArrayType))
			return true;

		// Numeric types are comparable with other numeric types
		if(type1.isNumeric() && type2.isNumeric())
			return true;

		// Boolean types are comparable only with other boolean types
		if(type1.equals(PrimitiveType.BOOL) && type2.equals(PrimitiveType.BOOL))
			return true;

		// Class types can be compared if they are in the same inheritance hierarchy (simplified here)
		// For a full implementation, you'd check if one is assignable from the other.
		if(type1 instanceof ClassType && type2 instanceof ClassType)
		{
			return type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1);
		}

		return false;
	}

	/**
	 * Checks if this type (the type of `this` object) is assignable to the target type.
	 * This method defines the type compatibility rules of the language.
	 *
	 * @param targetType The type to which this type is being assigned.
	 * @return True if this type can be assigned to targetType, false otherwise.
	 */
	public boolean isAssignableTo(Type targetType)
	{
		// A type is always assignable to itself.
		if(this.equals(targetType))
		{
			return true;
		}
		// Error types can be assigned to anything (or nothing) to prevent cascades.
		if(this instanceof ErrorType || targetType instanceof ErrorType)
		{
			return true; // Allows semantic analysis to continue
		}
		return false;
	}

	@Override
	public String toString()
	{
		return name;
	}

	@Override
	public boolean equals(Object o)
	{
		if(this == o)
			return true;
		if(o == null || getClass() != o.getClass())
			return false;
		Type type = (Type) o;
		return name.equals(type.name);
	}

	@Override
	public int hashCode()
	{
		return name.hashCode();
	}
}
semantics/ClassType.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/semantics/ClassType.java
package com.juanpa.nebula.transpiler.semantics;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Represents a user-defined class type in the Nebula language.
 * This type stores the fully qualified name of the class and a reference to its
 * corresponding {@link ClassSymbol} which holds its members and scope.
 */
public class ClassType extends Type
{
	// Fully qualified name (e.g., "System.Console", "MyNamespace.MyClass")
	private final String fqn;
	// Reference to the ClassSymbol that defines this class.
	// This is often set in two phases: first ClassType is created, then ClassSymbol is resolved.
	public ClassSymbol classSymbol; // Public for direct access during initialization
	private Type superClassType; // Can be null (for Object or classes not extending anything implicitly)

	public ClassType(String fqn, ClassSymbol classSymbol)
	{
		super(fqn);
		this.fqn = fqn;
		this.classSymbol = classSymbol;
		this.superClassType = null; // Initially null, set during semantic analysis
	}

	public ClassType(String fqn, ClassSymbol classSymbol, Type superClassType)
	{
		super(fqn);
		this.fqn = fqn;
		this.classSymbol = classSymbol;
		this.superClassType = superClassType;
	}

	public String getFqn()
	{
		return fqn;
	}

	public ClassSymbol getClassSymbol()
	{
		return classSymbol;
	}

	// Removed setClassSymbol as classSymbol is public and directly assigned.
	// public void setClassSymbol(ClassSymbol classSymbol) {
	// 	this.classSymbol = classSymbol;
	// }

	public Type getSuperClassType()
	{
		return superClassType;
	}

	public void setSuperClassType(Type superClassType)
	{
		this.superClassType = superClassType;
	}

	/**
	 * Checks if this class type can be assigned TO the target type.
	 * Handles inheritance (subclass to superclass assignments).
	 *
	 * @param targetType The type to which this class type is being assigned.
	 * @return True if this class type can be assigned to targetType, false otherwise.
	 */
	@Override
	public boolean isAssignableTo(Type targetType)
	{
		if(super.isAssignableTo(targetType))
			return true; // Handles self-assignment and ErrorType

		// A ClassType instance (non-null object) cannot be assigned TO NullType.
		// Only NullType.INSTANCE can be assigned to NullType.
		if(targetType instanceof NullType)
		{
			return false;
		}

		// A ClassType can only be assigned to another ClassType or Object.
		if(!(targetType instanceof ClassType))
		{
			return false;
		}

		ClassType targetClassType = (ClassType) targetType;

		// Check if 'this' is the same class as targetType, or a subclass of targetType.
		// Traverse up the inheritance hierarchy of 'this' class.
		ClassType currentTypeInHierarchy = this;
		while(currentTypeInHierarchy != null)
		{
			if(currentTypeInHierarchy.equals(targetClassType))
			{
				return true; // Found a match in the inheritance chain
			}
			// Move to the superclass. Assuming superClassType is properly set during analysis.
			if(currentTypeInHierarchy.getSuperClassType() instanceof ClassType)
			{
				currentTypeInHierarchy = (ClassType) currentTypeInHierarchy.getSuperClassType();
			}
			else
			{
				currentTypeInHierarchy = null; // Reached the top (Object) or a non-ClassType superclass
			}
		}

		// TODO: Add interface assignment checks here if you implement interfaces.

		return false;
	}

	@Override
	public boolean isAssignableFrom(Type other)
	{
		if(this.equals(other))
		{
			return true; // Same class type is always assignable
		}

		// Allow assigning null to any class type (reference type)
		if(other instanceof NullType)
		{ // Assuming a NullType exists for `null` literal
			return true;
		}

		// For class types, check inheritance hierarchy
		if(other instanceof ClassType)
		{
			ClassType otherClass = (ClassType) other;
			// A full implementation would traverse the 'extends' chain of otherClass.classSymbol
			// to see if 'this' class is in its hierarchy. For now, a simplified check.
			// E.g., `this` is `Object`, `other` is `MyClass`, then `MyClass` is assignable to `Object`.
			// If `otherClass.classSymbol` exists, and it is a subclass of `this.classSymbol`.
			// This would require a `isSubclassOf` method on ClassSymbol.
			if(otherClass.classSymbol != null && this.classSymbol != null)
			{
				// Assuming `isSubclassOf` correctly traverses inheritance
				// For now, simplify to check if they are the same ClassSymbol
				// or if the `otherClass` represents a "subclass" conceptually that can be assigned.
				// This is where proper inheritance tree walking is needed.
				// For now, let's keep it simple: only exact match for user-defined classes,
				// unless `other` is `NullType`.
				// More robust: 'otherClass' must be 'this' or a subclass of 'this'.
				ClassType currentOtherInHierarchy = otherClass;
				while(currentOtherInHierarchy != null)
				{
					if(currentOtherInHierarchy.equals(this))
					{
						return true;
					}
					if(currentOtherInHierarchy.getSuperClassType() instanceof ClassType)
					{
						currentOtherInHierarchy = (ClassType) currentOtherInHierarchy.getSuperClassType();
					}
					else
					{
						currentOtherInHierarchy = null;
					}
				}
			}
			return false; // Default to false if no explicit assignability rules met
		}
		return false;
	}

	@Override
	public boolean isCompatibleWith(Type other)
	{
		if(this.equals(other))
		{
			return true; // Same class type is compatible
		}
		// Generally, class types are not "compatible" for binary operations
		// unless it's a special case like String concatenation (which is handled in SemanticAnalyzer).
		// For general arithmetic or logical ops, they are not.
		return false;
	}

	/**
	 * Looks up a method by name and number of arguments within this class.
	 * This is a simplified lookup and doesn't handle overloading or full signature matching yet.
	 *
	 * @param methodName The name of the method.
	 * @param numArgs    The number of arguments the method call has.
	 * @return The resolved MethodSymbol, or null if not found.
	 */
	public MethodSymbol lookupMethod(String methodName, int numArgs)
	{
		if(this.classSymbol == null || this.classSymbol.getClassScope() == null)
		{
			return null;
		}
		// Iterate through all symbols in the class scope to find a matching method.
		for(Symbol symbol : this.classSymbol.getClassScope().symbols.values())
		{
			if(symbol instanceof MethodSymbol)
			{
				MethodSymbol method = (MethodSymbol) symbol;
				// Check name and parameter count
				if(method.getName().equals(methodName) && method.getParameterTypes().size() == numArgs)
				{
					// In a real compiler, you would also check parameter types for exact match (overloading)
					return method;
				}
			}
		}
		return null;
	}

	/**
	 * Looks up a constructor by argument types within this class.
	 * This is a simplified lookup.
	 *
	 * @param argTypes The list of argument types provided in the 'new' expression.
	 * @return The resolved MethodSymbol (representing a constructor), or null if no matching constructor found.
	 */
	public MethodSymbol lookupConstructor(List<Type> argTypes)
	{
		if(this.classSymbol == null || this.classSymbol.getClassScope() == null)
		{
			return null;
		}

		List<MethodSymbol> constructors = this.classSymbol.methodsByName.values().stream() // Corrected: use methodsByName
				.flatMap(List::stream)
				.filter(s -> s.isConstructor() && s.getName().equals(this.getName())) // Ensure it's a constructor with matching name
				.collect(Collectors.toList());

		for(MethodSymbol constructor : constructors)
		{
			if(constructor.matchesArguments(argTypes)) // Use the matchesArguments helper on MethodSymbol
			{
				return constructor;
			}
		}
		return null; // No matching constructor
	}


	@Override
	public boolean equals(Object o)
	{
		if(this == o)
			return true;
		// Specifically allow ClassType to equal PrimitiveType.STRING if their FQNs match
		// This handles cases where 'string' keyword maps to Nebula.Lang.String class.
		if(o instanceof PrimitiveType && ((PrimitiveType) o).getName().equals("String") && this.getFqn().equals("nebula.core.String"))
		{
			return true;
		}
		if(o == null || getClass() != o.getClass())
			return false;
		ClassType classType = (ClassType) o;
		return fqn.equals(classType.fqn); // Equality based on fully qualified name
	}

	@Override
	public int hashCode()
	{
		return fqn.hashCode();
	}
}

semantics/NamespaceType.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/semantics/NamespaceType.java
package com.juanpa.nebula.transpiler.semantics;

/**
 * Represents a namespace as a type. Used for structural information rather than a type with values.
 */
public class NamespaceType extends Type
{
	private final String qualifiedName;
	private final String parentNamespaceName; // Null for top-level namespaces

	public NamespaceType(String qualifiedName, String parentNamespaceName)
	{
		super(qualifiedName); // Name is the FQN
		this.qualifiedName = qualifiedName;
		this.parentNamespaceName = parentNamespaceName;
	}

	public String getQualifiedName()
	{
		return qualifiedName;
	}

	public String getParentNamespaceName()
	{
		return parentNamespaceName;
	}

	@Override
	public boolean isAssignableFrom(Type other)
	{
		// Namespaces are not assignable in the typical sense of values.
		// This is primarily a structural type.
		return false;
	}

	@Override
	public boolean isCompatibleWith(Type other)
	{
		// Namespaces are not compatible with other types for operations.
		return false;
	}

	@Override
	public boolean equals(Object o)
	{
		if(this == o)
			return true;
		if(o == null || getClass() != o.getClass())
			return false;
		if(!super.equals(o))
			return false; // Check name equality from base Type
		NamespaceType that = (NamespaceType) o;
		return qualifiedName.equals(that.qualifiedName);
	}

	@Override
	public int hashCode()
	{
		return super.hashCode();
	}
}
semantics/ArrayType.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/semantics/ArrayType.java
package com.juanpa.nebula.transpiler.semantics;

/**
 * Represents an array type in the Nebula language.
 * An array type is defined by its element type (e.g., int[], String[][]).
 */
public class ArrayType extends Type
{
	private final Type elementType;
	// Potentially add dimensions if multi-dimensional arrays are distinct types (e.g., int[][])
	// For simplicity, this assumes single-dimensional arrays or that multi-dimensional
	// arrays are represented as arrays of arrays.

	public ArrayType(Type elementType)
	{
		super(elementType.getName() + "[]"); // Name like "int[]"
		this.elementType = elementType;
	}

	public Type getElementType()
	{
		return elementType;
	}

	/**
	 * Checks if this array type can be assigned TO the target type.
	 * Handles assignability for arrays (e.g., subclass array to superclass array).
	 *
	 * @param targetType The type to which this array type is being assigned.
	 * @return True if this array type can be assigned to targetType, false otherwise.
	 */
	@Override
	public boolean isAssignableTo(Type targetType)
	{
		if(super.isAssignableTo(targetType))
			return true; // Handles self-assignment and ErrorType

		// An ArrayType instance (non-null array) cannot be assigned TO NullType.
		// Only NullType.INSTANCE can be assigned to NullType.
		if(targetType instanceof NullType)
		{
			return false;
		}

		// An array type can only be assigned to another array type.
		if(!(targetType instanceof ArrayType))
		{
			return false;
		}

		ArrayType otherArrayType = (ArrayType) targetType;

		// Covariance: If T' is a subtype of T, then T'[] is assignable to T[].
		// This means `this.elementType` must be assignable to `otherArrayType.elementType`.
		// E.g., `String[]` is assignable to `Object[]` if `String` is assignable to `Object`.
		return this.elementType.isAssignableTo(otherArrayType.elementType);
	}

	@Override
	public boolean isAssignableFrom(Type other)
	{
		if(this.equals(other))
		{
			return true; // Same array type is always assignable
		}
		// Allow assigning null to any array type
		if(other instanceof NullType)
		{ // Assuming a NullType exists for `null` literal
			return true;
		}
		// Allow assigning an array of a more specific type to a more general type (covariance, if supported)
		// For simplicity, require exact match for now, or allow if element types are assignable.
		if(other instanceof ArrayType)
		{
			ArrayType otherArrayType = (ArrayType) other;
			// Covariance: A String[] is assignable to an Object[] (if Object is base type)
			// For now, require exact element type match or allow assignability of element types.
			return this.elementType.isAssignableFrom(otherArrayType.elementType);
		}
		return false;
	}

	@Override
	public boolean isCompatibleWith(Type other)
	{
		if(this.equals(other))
		{
			return true; // Same array type is compatible
		}
		// Arrays are generally not compatible with other types for binary operations,
		// unless specific language features like array concatenation are introduced.
		// For now, only compatible with other ArrayTypes of compatible element types.
		if(other instanceof ArrayType)
		{
			ArrayType otherArrayType = (ArrayType) other;
			return this.elementType.isCompatibleWith(otherArrayType.elementType);
		}
		return false;
	}

	@Override
	public boolean equals(Object o)
	{
		if(this == o)
			return true;
		if(o == null || getClass() != o.getClass())
			return false;
		// Do not call super.equals(o) directly if Type's equals method checks getClass()
		// Instead, directly check the name field inherited from Type.
		// If super.equals() checks getClass(), it would return false if the other is not exactly Type.
		// Type's equals: `if (o == null || getClass() != o.getClass()) return false;`
		// This means we CANNOT call super.equals() if `o` might be a subclass.
		// We need to re-implement the name check here directly.
		// The `name` field is protected, so `((Type)o).name` is accessible.
		if(!this.name.equals(((Type) o).name))
			return false;

		ArrayType arrayType = (ArrayType) o;
		return elementType.equals(arrayType.elementType);
	}

	@Override
	public int hashCode()
	{
		return super.hashCode() + elementType.hashCode();
	}
}

semantics/VariableSymbol.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/semantics/VariableSymbol.java

package com.juanpa.nebula.transpiler.semantics;

import com.juanpa.nebula.transpiler.lexer.Token;

/**
 * Represents a variable (local variable, parameter, or field) in the symbol table.
 * Stores its name, type, initialization status, static status, and const status.
 */
public class VariableSymbol extends Symbol
{
	private boolean initialized;
	private final boolean isStatic; // Indicates if it's a static field
	private final boolean isConst;  // Indicates if it's a constant variable/field
	private ClassSymbol ownerClass; // NEW: Reference to the ClassSymbol this variable (if a field) belongs to


	/**
	 * Constructs a VariableSymbol.
	 *
	 * @param name             The name of the variable.
	 * @param type             The type of the variable.
	 * @param declarationToken The token where this variable was declared.
	 * @param initialized      True if the variable is initialized at declaration, false otherwise.
	 * @param isStatic         True if this is a static field, false otherwise.
	 * @param isConst          True if this is a constant variable/field, false otherwise.
	 * @param isPublic         True if this field is public, false otherwise. (Relevant for fields)
	 */
	public VariableSymbol(String name, Type type, Token declarationToken, boolean initialized, boolean isStatic, boolean isConst, boolean isPublic)
	{
		super(name, type, declarationToken, isPublic); // Pass isPublic to super
		this.initialized = initialized;
		this.isStatic = isStatic;
		this.isConst = isConst;
		this.ownerClass = null; // Initialize to null; set by SemanticAnalyzer for fields
	}

	/**
	 * Constructs a VariableSymbol (for non-static, non-const, non-public variables, e.g., local vars, params).
	 */
	public VariableSymbol(String name, Type type, Token declarationToken, boolean initialized)
	{
		this(name, type, declarationToken, initialized, false, false, false); // Default to non-static, non-const, non-public
	}

	// Overloaded constructor for parameters/local variables where public/static/const might be less relevant or default
	public VariableSymbol(String name, Type type, Token declarationToken, boolean initialized, boolean isStatic, boolean isConst)
	{
		this(name, type, declarationToken, initialized, isStatic, isConst, false); // Default to non-public
	}


	public boolean isInitialized()
	{
		return initialized;
	}

	public void setInitialized(boolean initialized)
	{
		this.initialized = initialized;
	}

	@Override
	public boolean isStatic()
	{
		return isStatic;
	}

	/**
	 * Indicates whether this variable/field is constant.
	 *
	 * @return True if the variable/field is constant, false otherwise.
	 */
	public boolean isConst()
	{
		return isConst;
	}

	/**
	 * Gets the owning ClassSymbol for this variable, if it is a field.
	 *
	 * @return The ClassSymbol that owns this variable, or null if it's a local variable or parameter.
	 */
	public ClassSymbol getOwnerClass()
	{
		return ownerClass;
	}

	/**
	 * Sets the owning ClassSymbol for this variable. This should be called by the SemanticAnalyzer
	 * when defining fields within a class.
	 *
	 * @param ownerClass The ClassSymbol that owns this variable.
	 */
	public void setOwnerClass(ClassSymbol ownerClass)
	{
		this.ownerClass = ownerClass;
	}


	@Override
	public String toString()
	{
		return "VariableSymbol{" + "name='" + getName() + '\'' + ", type=" + getType() + ", initialized=" + initialized + ", static=" + isStatic() + ", const=" + isConst() + ", public=" + isPublic() + (ownerClass != null ? ", owner=" + ownerClass.getName() : "") + '}';
	}
}

lexer/NebulaLexer.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/lexer/NebulaLexer.java

package com.juanpa.nebula.transpiler.lexer;

import com.juanpa.nebula.transpiler.util.ErrorReporter;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * The NebulaLexer is responsible for performing lexical analysis (scanning).
 * It reads the raw Nebula source code and converts it into a stream of meaningful Tokens.
 * This class identifies keywords, identifiers, literals, operators, and punctuation.
 */
public class NebulaLexer
{
	private final String source; // The raw source code string
	private final List<Token> tokens = new ArrayList<>(); // List to store generated tokens
	private final ErrorReporter errorReporter; // For reporting lexical errors

	private int start = 0; // Current token's starting position in the source
	private int current = 0; // Current position in the source
	private int line = 1; // Current line number
	private int column = 1; // Current column number

	// Static map to store reserved keywords for quick lookup
	private static final Map<String, TokenType> keywords;

	static
	{
		keywords = new HashMap<>();
		keywords.put("class", TokenType.CLASS);
		keywords.put("public", TokenType.PUBLIC);
		keywords.put("private", TokenType.PRIVATE);
		keywords.put("static", TokenType.STATIC);
		keywords.put("void", TokenType.VOID);
		keywords.put("string", TokenType.STRING_KEYWORD); // 'string' is a keyword, not just an identifier
		keywords.put("int", TokenType.INT);
		keywords.put("bool", TokenType.BOOL);
		keywords.put("float", TokenType.FLOAT);
		keywords.put("double", TokenType.DOUBLE);
		keywords.put("byte", TokenType.BYTE);
		keywords.put("var", TokenType.VAR);
		keywords.put("new", TokenType.NEW);
		keywords.put("this", TokenType.THIS);
		keywords.put("if", TokenType.IF);
		keywords.put("else", TokenType.ELSE);
		keywords.put("for", TokenType.FOR);
		keywords.put("while", TokenType.WHILE);
		keywords.put("do", TokenType.DO);
		keywords.put("extends", TokenType.EXTENDS);
		keywords.put("return", TokenType.RETURN);
		keywords.put("namespace", TokenType.NAMESPACE);
		keywords.put("get", TokenType.GET);
		keywords.put("set", TokenType.SET);
		keywords.put("throw", TokenType.THROW);
		keywords.put("try", TokenType.TRY);
		keywords.put("catch", TokenType.CATCH);
		keywords.put("finally", TokenType.FINALLY);
		keywords.put("result", TokenType.RESULT);
		keywords.put("operator", TokenType.OPERATOR);
		keywords.put("char", TokenType.CHAR);
		keywords.put("true", TokenType.BOOLEAN_LITERAL);
		keywords.put("false", TokenType.BOOLEAN_LITERAL);
		keywords.put("const", TokenType.CONST);
		keywords.put("import", TokenType.IMPORT);
		keywords.put("global", TokenType.GLOBAL);
		keywords.put("switch", TokenType.SWITCH);
		keywords.put("case", TokenType.CASE);
		keywords.put("default", TokenType.DEFAULT);
		keywords.put("is", TokenType.IS);
	}

	/**
	 * Constructs a NebulaLexer.
	 *
	 * @param source        The source code string to tokenize.
	 * @param errorReporter An instance of ErrorReporter for logging errors.
	 */
	public NebulaLexer(String source, ErrorReporter errorReporter)
	{
		this.source = source;
		this.errorReporter = errorReporter;
	}

	/**
	 * Scans the entire source code and returns a list of tokens.
	 *
	 * @return A list of tokens, including an EOF token at the end.
	 */
	public List<Token> scanTokens()
	{
		while(!isAtEnd())
		{
			start = current; // Mark the beginning of the current token
			scanToken(); // Scan and add the next token
		}

		// Add the End Of File token
		tokens.add(new Token(TokenType.EOF, "", null, line, column));
		return tokens;
	}

	/**
	 * Scans a single token from the source code.
	 */
	private void scanToken()
	{
		char c = advance(); // Get and consume the current character

		switch(c)
		{
			// --- Single-character tokens ---
			case '(':
				addToken(TokenType.LEFT_PAREN);
				break;
			case ')':
				addToken(TokenType.RIGHT_PAREN);
				break;
			case '{':
				addToken(TokenType.LEFT_BRACE);
				break;
			case '}':
				addToken(TokenType.RIGHT_BRACE);
				break;
			case '[':
				addToken(TokenType.LEFT_BRACKET);
				break;
			case ']':
				addToken(TokenType.RIGHT_BRACKET);
				break;
			case ',':
				addToken(TokenType.COMMA);
				break;
			case ';':
				addToken(TokenType.SEMICOLON);
				break;
			case '?':
				addToken(TokenType.QUESTION);
				break;
			case ':': // Added COLON
				addToken(TokenType.COLON);
				break;

			// --- Operators that can be single or double characters ---
			case '+':
				if(match('+'))
				{
					addToken(TokenType.PLUS_PLUS);
				}
				else if(match('='))
				{
					addToken(TokenType.PLUS_ASSIGN);
				}
				else
				{
					addToken(TokenType.PLUS);
				}
				break;
			case '-':
				if(match('-'))
				{
					addToken(TokenType.MINUS_MINUS);
				}
				else if(match('='))
				{
					addToken(TokenType.MINUS_ASSIGN);
				}
				else
				{
					addToken(TokenType.MINUS);
				}
				break;
			case '*':
				if(match('='))
				{
					addToken(TokenType.STAR_ASSIGN);
				}
				else
				{
					addToken(TokenType.STAR);
				}
				break;
			case '/':
				if(match('='))
				{
					addToken(TokenType.SLASH_ASSIGN);
				}
				else if(match('/'))
				{
					// It's a single-line comment, consume until newline
					while(peek() != '\n' && !isAtEnd())
					{
						advance();
					}
				}
				else if(match('*'))
				{
					// Multi-line comment, consume until '*/'
					while(!(peek() == '*' && peekNext() == '/') && !isAtEnd())
					{
						if(peek() == '\n')
						{
							line++;
							column = 0; // Reset column for new line
						}
						advance();
					}
					if(!isAtEnd())
					{ // Consume '*/'
						advance();
						advance();
					}
					else
					{
						error("Unterminated multi-line comment.");
					}
				}
				else
				{
					addToken(TokenType.SLASH);
				}
				break;
			case '%':
				if(match('='))
				{
					addToken(TokenType.MODULO_ASSIGN);
				}
				else
				{
					addToken(TokenType.MODULO);
				}
				break;
			case '=':
				addToken(match('=') ? TokenType.EQUAL_EQUAL : TokenType.ASSIGN);
				break;
			case '!':
				addToken(match('=') ? TokenType.BANG_EQUAL : TokenType.BANG);
				break;
			case '<':
				addToken(match('=') ? TokenType.LESS_EQUAL : TokenType.LESS);
				break;
			case '>':
				addToken(match('=') ? TokenType.GREATER_EQUAL : TokenType.GREATER);
				break;
			case '&':
				if(match('&'))
				{
					addToken(TokenType.AMPERSAND_AMPERSAND);
				}
				else
				{
					addToken(TokenType.AMPERSAND);
				}
				break;
			case '|':
				if(match('|'))
				{
					addToken(TokenType.PIPE_PIPE);
				}
				else
				{
					addToken(TokenType.PIPE);
				}
				break;
			case '.':
				if(Character.isDigit(peek()))
				{
					error("Floating point number cannot start with a decimal point. Expected a digit before '.'.");
					addToken(TokenType.DOT);
				}
				else
				{
					addToken(TokenType.DOT);
				}
				break;


			// --- Literals and Identifiers ---
			case '"':
				scanStringLiteral();
				break;
			case '\'':
				scanCharacterLiteral();
				break;

			// --- Whitespace ---
			case ' ':
			case '\r':
			case '\t':
				// Ignore whitespace.
				break;
			case '\n':
				line++;
				column = 0; // Reset column for new line
				break;

			default:
				if(Character.isDigit(c))
				{ // Corrected: Use Character.isDigit()
					scanNumber();
				}
				else if(Character.isLetter(c) || c == '_')
				{ // Corrected: Use Character.isLetter()
					scanIdentifier();
				}
				else
				{
					error("Unexpected character '" + c + "'.");
					addToken(TokenType.ERROR, null); // Add an error token to continue parsing
				}
				break;
		}
	}

	/**
	 * Consumes the current character and returns it, also updates line/column.
	 *
	 * @return The consumed character.
	 */
	private char advance()
	{
		char c = source.charAt(current++);
		column++; // Increment column for the consumed character
		return c;
	}

	/**
	 * Adds a token to the list of tokens.
	 *
	 * @param type    The TokenType of the token.
	 * @param literal The literal value of the token (for numbers, strings, booleans).
	 */
	private void addToken(TokenType type, Object literal)
	{
		String text = source.substring(start, current);
		tokens.add(new Token(type, text, literal, line, column - text.length())); // Adjust column to be start of token
	}

	/**
	 * Overloaded method to add a token without a literal value.
	 *
	 * @param type The TokenType of the token.
	 */
	private void addToken(TokenType type)
	{
		addToken(type, null);
	}

	/**
	 * Checks if the current character matches the expected character.
	 * If it matches, consumes it (advances `current`).
	 *
	 * @param expected The expected character.
	 * @return True if the character matched and was consumed, false otherwise.
	 */
	private boolean match(char expected)
	{
		if(isAtEnd())
			return false;
		if(source.charAt(current) != expected)
			return false;

		current++;
		column++; // Increment column for the matched character
		return true;
	}

	/**
	 * Looks at the current character without consuming it.
	 *
	 * @return The current character, or '\0' if at the end of the source.
	 */
	private char peek()
	{
		if(isAtEnd())
			return '\0';
		return source.charAt(current);
	}

	/**
	 * Looks at the next character (one position ahead) without consuming it.
	 *
	 * @return The next character, or '\0' if at or beyond the end of the source.
	 */
	private char peekNext()
	{
		if(current + 1 >= source.length())
			return '\0';
		return source.charAt(current + 1);
	}

	/**
	 * Checks if the lexer has reached the end of the code.
	 *
	 * @return True if at the end, false otherwise.
	 */
	private boolean isAtEnd()
	{
		return current >= source.length();
	}

	/**
	 * Reports a lexical error.
	 *
	 * @param message The error message.
	 */
	private void error(String message)
	{
		errorReporter.report(line, column - (current - start), "[Lexical Error] " + message);
	}

	/**
	 * Scans a number literal (integer, float, or double).
	 */
	private void scanNumber()
	{
		// Consume all digits before the decimal point
		while(Character.isDigit(peek()))
		{
			advance();
		}

		// Check for a decimal point and subsequent digits (for float/double)
		boolean isFloatingPoint = false;
		if(peek() == '.' && Character.isDigit(peekNext()))
		{
			isFloatingPoint = true;
			advance(); // Consume the '.'
			while(Character.isDigit(peek()))
			{
				advance();
			}
		}

		String numberStr = source.substring(start, current);

		// Check for float/double literal suffixes ('f', 'F', 'd', 'D')
		if(isFloatingPoint)
		{
			if(peek() == 'f' || peek() == 'F')
			{
				advance(); // Consume 'f'
				try
				{
					addToken(TokenType.FLOAT_LITERAL, Float.parseFloat(numberStr));
				}
				catch(NumberFormatException e)
				{
					error("Invalid float literal: " + numberStr);
					addToken(TokenType.ERROR, null);
				}
			}
			else if(peek() == 'd' || peek() == 'D')
			{
				advance(); // Consume 'd'
				try
				{
					addToken(TokenType.DOUBLE_LITERAL, Double.parseDouble(numberStr));
				}
				catch(NumberFormatException e)
				{
					error("Invalid double literal: " + numberStr);
					addToken(TokenType.ERROR, null);
				}
			}
			else
			{
				// Default to DOUBLE_LITERAL if no suffix or unknown suffix
				try
				{
					addToken(TokenType.DOUBLE_LITERAL, Double.parseDouble(numberStr));
				}
				catch(NumberFormatException e)
				{
					error("Invalid double literal: " + numberStr);
					addToken(TokenType.ERROR, null);
				}
			}
		}
		else
		{
			// It's an integer literal
			try
			{
				addToken(TokenType.INTEGER_LITERAL, Integer.parseInt(numberStr));
			}
			catch(NumberFormatException e)
			{
				error("Invalid integer literal: " + numberStr);
				addToken(TokenType.ERROR, null);
			}
		}
	}


	/**
	 * Scans a string literal enclosed in double quotes.
	 */
	private void scanStringLiteral()
	{
		StringBuilder value = new StringBuilder();
		while(peek() != '"' && !isAtEnd())
		{
			char c = advance(); // Consume character
			if(c == '\\')
			{ // Handle escape sequences inside strings
				if(isAtEnd())
				{
					error("Unterminated escape sequence in string literal.");
					break;
				}
				char escapeChar = advance(); // Consume the escaped character
				switch(escapeChar)
				{
					case 'n':
						value.append('\n');
						break;
					case 't':
						value.append('\t');
						break;
					case 'r':
						value.append('\r');
						break;
					case 'b':
						value.append('\b');
						break;
					case 'f':
						value.append('\f');
						break;
					case '"':
						value.append('"');
						break;
					case '\\':
						value.append('\\');
						break;
					case '0':
						value.append('\0'); // Null character
						break;
					default:
						error("Invalid escape sequence '\\" + escapeChar + "' in string literal.");
						value.append(c).append(escapeChar); // Append as-is if invalid escape
						break;
				}
			}
			else if(c == '\n')
			{
				error("Newline in string literal.");
				// Do not break, consume newline, but report error. Parser needs to handle this.
				value.append(c);
				line++;
				column = 0; // Reset column for new line
			}
			else
			{
				value.append(c);
			}
		}

		if(isAtEnd())
		{
			error("Unterminated string literal.");
			addToken(TokenType.ERROR, null); // Add error token and return
			return;
		}

		advance(); // Consume the closing '"'
		addToken(TokenType.STRING_LITERAL, value.toString());
	}


	/**
	 * Scans a character literal enclosed in single quotes.
	 */
	private void scanCharacterLiteral()
	{
		// Consume the opening single quote
		// `start` already points to the beginning of the literal (before the first '\'')
		// `current` is on the character after the first '\''
		char charValue;

		if(isAtEnd())
		{
			error("Unterminated character literal.");
			addToken(TokenType.ERROR, null);
			return;
		}

		char c = peek();
		if(c == '\\')
		{ // Handle escape sequences
			advance(); // Consume '\'
			if(isAtEnd())
			{
				error("Unterminated escape sequence in character literal.");
				addToken(TokenType.ERROR, null);
				return;
			}
			char escapeChar = advance(); // Consume the escaped character
			switch(escapeChar)
			{
				case 'n':
					charValue = '\n';
					break;
				case 't':
					charValue = '\t';
					break;
				case 'r':
					charValue = '\r';
					break;
				case 'b':
					charValue = '\b';
					break;
				case 'f':
					charValue = '\f';
					break;
				case '\'':
					charValue = '\'';
					break;
				case '\\':
					charValue = '\\';
					break;
				case '0':
					charValue = '\0'; // Specifically handle null character
					break;
				default:
					error("Invalid escape sequence '\\" + escapeChar + "' in character literal.");
					charValue = '\0'; // Assign dummy value for error recovery
			}
		}
		else if(c == '\n' || c == '\r')
		{
			error("Newline in character literal.");
			charValue = '\0'; // Assign dummy value for error recovery
		}
		else
		{
			charValue = advance(); // Consume the character itself
		}

		// Check for closing single quote
		if(isAtEnd() || peek() != '\'')
		{
			error("Unterminated character literal. Expected '.");
			addToken(TokenType.ERROR, null);
			// Try to recover by advancing until end of line or next quote
			while(!isAtEnd() && peek() != '\n' && peek() != '\'')
			{
				advance();
			}
			if(!isAtEnd() && peek() == '\'')
			{ // If we found the closing quote
				advance(); // Consume it
			}
			return;
		}

		advance(); // Consume the closing single quote
		addToken(TokenType.CHAR_LITERAL, charValue);
	}


	/**
	 * Scans an identifier (variable name, class name, method name, keyword).
	 */
	private void scanIdentifier()
	{
		while(Character.isLetterOrDigit(peek()) || peek() == '_')
		{ // Corrected: Use Character.isLetterOrDigit()
			advance();
		}

		String text = source.substring(start, current);
		TokenType type = keywords.get(text); // Check if it's a reserved keyword

		if(type == null)
		{
			type = TokenType.IDENTIFIER; // If not a keyword, it's an identifier
			addToken(type); // Identifiers don't have literal values
		}
		else
		{
			// Check if it's a boolean literal keyword ('true' or 'false')
			if(type == TokenType.BOOLEAN_LITERAL)
			{
				// Parse the boolean string and pass the Boolean object as the literal value
				addToken(type, Boolean.parseBoolean(text));
			}
			else
			{
				// For other keywords (like 'class', 'void', 'if', etc.), they don't have a literal value.
				addToken(type); // This calls addToken(type, null) implicitly.
			}
		}
	}
}

lexer/Token.java:
[AND the contents]
package com.juanpa.nebula.transpiler.lexer;

import java.util.Objects;

/**
 * Represents a single token produced by the Nebula Lexer.
 * Each token encapsulates its type, the actual text (lexeme),
 * and its position in the source file for error reporting.
 */
public class Token
{
	private final TokenType type;    // The classification of the token (e.g., IDENTIFIER, INT, PLUS)
	private final String lexeme;     // The actual text of the token (e.g., "myVariable", "123", "+")
	private final Object literal;    // The parsed value of the literal (e.g., Integer 123, String "hello")
	private final int line;          // The line number in the source file where the token starts
	private final int column;        // The column number in the source file where the token starts

	/**
	 * Constructs a new Token instance.
	 *
	 * @param type    The TokenType of this token.
	 * @param lexeme  The raw string value of the token from the source code.
	 * @param literal The parsed literal value for literal tokens (e.g., for "123" it's the Integer object 123,
	 *                for "true" it's the Boolean object true). Null for non-literal tokens.
	 * @param line    The line number where this token begins.
	 * @param column  The column number where this token begins.
	 */
	public Token(TokenType type, String lexeme, Object literal, int line, int column)
	{
		this.type = type;
		this.lexeme = lexeme;
		this.literal = literal;
		this.line = line;
		this.column = column;
	}

	// --- Getters for Token properties ---

	public TokenType getType()
	{
		return type;
	}

	public String getLexeme()
	{
		return lexeme;
	}

	public Object getLiteral()
	{
		return literal;
	}

	public int getLine()
	{
		return line;
	}

	public int getColumn()
	{
		return column;
	}

	/**
	 * Provides a string representation of the Token, useful for debugging.
	 * Format: "TokenType Lexeme [Literal] (Line:Column)"
	 */
	@Override
	public String toString()
	{
		String literalStr = (literal != null) ? " [" + literal + "]" : "";
		return type + " '" + lexeme + "'" + literalStr + " (Line:" + line + ", Col:" + column + ")";
	}

	/**
	 * Basic equality check for tokens, primarily for testing purposes.
	 * Compares type, lexeme, and literal. Line/column are not included as
	 * tokens from different positions could still be considered "the same"
	 * for semantic comparison.
	 */
	@Override
	public boolean equals(Object o)
	{
		if(this == o)
			return true;
		if(o == null || getClass() != o.getClass())
			return false;

		Token token = (Token) o;

		if(type != token.type)
			return false;
		if(!lexeme.equals(token.lexeme))
			return false;
		return Objects.equals(literal, token.literal);
	}

	/**
	 * Generates a hash code for the token.
	 */
	@Override
	public int hashCode()
	{
		int result = type.hashCode();
		result = 31 * result + lexeme.hashCode();
		result = 31 * result + (literal != null ? literal.hashCode() : 0);
		return result;
	}
}
lexer/TokenType.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/lexer/TokenType.java

package com.juanpa.nebula.transpiler.lexer;

/**
 * Defines the types of tokens recognized by the Nebula Lexer.
 * This enum covers keywords, operators, literals, punctuation, and special tokens.
 */
public enum TokenType
{
	// --- Keywords ---
	CLASS, PUBLIC, PRIVATE, STATIC, VOID, STRING_KEYWORD, INT, BOOL, FLOAT, DOUBLE, BYTE, VAR,
	NEW, THIS, IF, ELSE, FOR, WHILE, DO, EXTENDS, RETURN,
	NAMESPACE, GET, SET, THROW, TRY, CATCH, FINALLY,
	RESULT, OPERATOR, CHAR,
	CONST,
	IMPORT,
	GLOBAL,
	SWITCH, // Added for switch statement
	CASE,   // Added for switch statement
	DEFAULT, // Added for switch statement
	IS, //For type checking
	SUPER, // NEW: Added for super constructor calls

	// --- Identifiers ---
	IDENTIFIER,

	// --- Literals ---
	INTEGER_LITERAL,
	STRING_LITERAL,
	CHAR_LITERAL,
	BOOLEAN_LITERAL,
	FLOAT_LITERAL,
	DOUBLE_LITERAL,

	// --- Operators ---
	PLUS, MINUS, STAR, SLASH, MODULO,
	EQUAL_EQUAL, BANG_EQUAL,
	LESS, GREATER, LESS_EQUAL, GREATER_EQUAL,
	NULL_COALESCING,

	ASSIGN,
	PLUS_ASSIGN,
	MINUS_ASSIGN,
	STAR_ASSIGN,
	SLASH_ASSIGN,
	MODULO_ASSIGN,

	PLUS_PLUS,
	MINUS_MINUS,

	DOT,
	COMMA,
	SEMICOLON,
	QUESTION,
	AMPERSAND,
	AMPERSAND_AMPERSAND,
	PIPE,
	PIPE_PIPE,
	BANG,

	COLON, // Added for switch statement case labels


	// --- Punctuation & Delimiters ---
	LEFT_PAREN, RIGHT_PAREN,
	LEFT_BRACE, RIGHT_BRACE,
	LEFT_BRACKET, RIGHT_BRACKET,

	// --- Special Tokens ---
	EOF, // End Of File
	ERROR // For lexical errors
}

parser/NebulaParser.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/parser/NebulaParser.java

package com.juanpa.nebula.transpiler.parser;

import com.juanpa.nebula.transpiler.ast.Program;
import com.juanpa.nebula.transpiler.ast.ASTNode;
import com.juanpa.nebula.transpiler.ast.declarations.ClassDeclaration;
import com.juanpa.nebula.transpiler.ast.declarations.MethodDeclaration;
import com.juanpa.nebula.transpiler.ast.declarations.NamespaceDeclaration;
import com.juanpa.nebula.transpiler.ast.declarations.ConstructorDeclaration;
import com.juanpa.nebula.transpiler.ast.declarations.FieldDeclaration;
import com.juanpa.nebula.transpiler.ast.declarations.ImportDirective;
import com.juanpa.nebula.transpiler.ast.expressions.*;
import com.juanpa.nebula.transpiler.ast.statements.*;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.lexer.TokenType;
import com.juanpa.nebula.transpiler.util.ErrorReporter;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * The NebulaParser is responsible for performing syntactic analysis.
 * It takes a list of tokens from the lexer and attempts to build an
 * Abstract Syntax Tree (AST) based on the Nebula language grammar.
 * This parser uses a recursive-descent approach.
 */
public class NebulaParser
{
	private final List<Token> tokens; // The list of tokens from the lexer
	private final ErrorReporter errorReporter; // For reporting parsing errors
	private int current = 0; // Current position in the token list

	// Field to keep track of the current fully qualified namespace being parsed
	private String currentNamespaceFqn = ""; // Initialized to empty string for global scope

	/**
	 * Constructs a NebulaParser.
	 *
	 * @param tokens        The list of tokens produced by the lexer.
	 * @param errorReporter An instance of ErrorReporter for handling parsing errors.
	 */
	public NebulaParser(List<Token> tokens, ErrorReporter errorReporter)
	{
		this.tokens = tokens;
		this.errorReporter = errorReporter;
	}

	/**
	 * Starts the parsing process for the entire Nebula program.
	 *
	 * @return The root of the parsed AST (a Program node), or null if parsing fails significantly.
	 */
	public Program parse()
	{
		Program program = new Program();
		while(!isAtEnd())
		{
			try
			{
				// Prioritize parsing 'import' directives before namespace declarations
				if(check(TokenType.IMPORT) || check(TokenType.GLOBAL) || check(TokenType.STATIC))
				{
					int tempCurrent = current;
					boolean hasImport = false;
					while(tempCurrent < tokens.size())
					{
						if(tokens.get(tempCurrent).getType() == TokenType.IMPORT)
						{
							hasImport = true;
							break;
						}
						if(!(tokens.get(tempCurrent).getType() == TokenType.GLOBAL || tokens.get(tempCurrent).getType() == TokenType.STATIC))
						{
							break;
						}
						tempCurrent++;
					}

					if(hasImport)
					{
						program.addImportDirective(importDirective());
						continue;
					}
				}

				if(check(TokenType.NAMESPACE))
				{
					program.addNamespace(namespaceDeclaration());
				}
				else
				{
					error(peek(), "Expected an 'import' directive or a namespace declaration at the top level.");
					synchronize();
				}
			}
			catch(SyntaxError e)
			{
				synchronize();
			}
		}
		return program;
	}

	/**
	 * Parses an 'import' directive.
	 * Grammar: `(GLOBAL | STATIC)* IMPORT QUALIFIED_NAME ;`
	 *
	 * @return An ImportDirective AST node.
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private ImportDirective importDirective() throws SyntaxError
	{
		List<Token> modifiers = new ArrayList<>();
		while(check(TokenType.GLOBAL) || check(TokenType.STATIC))
		{
			modifiers.add(advance());
		}

		Token importKeyword = consume(TokenType.IMPORT, "Expected 'import' keyword.");
		Expression qualifiedNameExpr = qualifiedName();
		consume(TokenType.SEMICOLON, "Expected ';' after 'import' directive.");

		return new ImportDirective(modifiers, importKeyword, qualifiedNameExpr);
	}


	/**
	 * Parses a qualified name (e.g., `Com.MyCompany.App`).
	 * Grammar: `IDENTIFIER (DOT IDENTIFIER)*`
	 *
	 * @return An Expression representing the qualified name (e.g., a chain of DotExpressions).
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private Expression qualifiedName() throws SyntaxError
	{
		Expression namePart = new IdentifierExpression(consume(TokenType.IDENTIFIER, "Expected identifier for qualified name."));

		while(match(TokenType.DOT))
		{
			Token dotToken = previous();
			Token rightPart = consume(TokenType.IDENTIFIER, "Expected identifier after '.'.");
			namePart = new DotExpression(namePart, dotToken, rightPart);
		}
		return namePart;
	}

	/**
	 * Parses a namespace declaration.
	 * Grammar: `NAMESPACE QUALIFIED_NAME { (CLASS_DECLARATION | ...)* }`
	 *
	 * @return A NamespaceDeclaration AST node.
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private NamespaceDeclaration namespaceDeclaration() throws SyntaxError
	{
		consume(TokenType.NAMESPACE, "Expected 'namespace' keyword.");
		Expression namespaceNameExpr = qualifiedName();

		// Get the FQN string of the current namespace being entered
		String newNamespaceSegment = getExpressionFQN(namespaceNameExpr);
		String previousNamespaceFqn = this.currentNamespaceFqn; // Save previous FQN

		// Update currentNamespaceFqn for nested parsing
		if (this.currentNamespaceFqn.isEmpty()) {
			this.currentNamespaceFqn = newNamespaceSegment;
		} else {
			this.currentNamespaceFqn += "." + newNamespaceSegment;
		}

		consume(TokenType.LEFT_BRACE, "Expected '{' after namespace name.");

		NamespaceDeclaration namespaceDecl = new NamespaceDeclaration(namespaceNameExpr);

		while(!check(TokenType.RIGHT_BRACE) && !isAtEnd())
		{
			List<Token> classModifiers = new ArrayList<>();
			while(check(TokenType.PUBLIC) || check(TokenType.PRIVATE) || check(TokenType.STATIC))
			{
				classModifiers.add(advance());
			}

			if(check(TokenType.CLASS))
			{
				// Pass the current fully qualified namespace to classDeclaration
				namespaceDecl.addClass(classDeclaration(classModifiers, this.currentNamespaceFqn));
			}
			else
			{
				error(peek(), "Expected 'class' declaration or '}' to close namespace body.");
				synchronizeNamespaceBody();
			}
		}

		consume(TokenType.RIGHT_BRACE, "Expected '}' after namespace body.");
		this.currentNamespaceFqn = previousNamespaceFqn; // Restore previous FQN
		return namespaceDecl;
	}

	/**
	 * Helper to get the fully qualified name string from an Expression (Identifier or DotExpression).
	 * This is useful for building the 'currentNamespaceFqn' string.
	 */
	private String getExpressionFQN(Expression expr) {
		if (expr instanceof IdentifierExpression) {
			return ((IdentifierExpression) expr).getName().getLexeme();
		} else if (expr instanceof DotExpression) {
			DotExpression dotExpr = (DotExpression) expr;
			return getExpressionFQN(dotExpr.getLeft()) + "." + dotExpr.getMemberName().getLexeme();
		}
		return "";
	}


	/**
	 * Helper to synchronize parsing within a namespace body in case of an error.
	 * Skips tokens until a known class declaration start or closing brace.
	 */
	private void synchronizeNamespaceBody()
	{
		advance();

		while(!isAtEnd())
		{
			TokenType type = peek().getType();
			switch(type)
			{
				case CLASS:
				case RIGHT_BRACE:
				case PUBLIC:
				case PRIVATE:
				case STATIC:
					return;
				default:
					advance();
			}
		}
	}

	/**
	 * Parses a class declaration, including its name, optional superclass, and members.
	 * Grammar: (MODIFIERS)* 'class' IDENTIFIER ('extends' IDENTIFIER)? '{' (MEMBERS)* '}'
	 *
	 * @param modifiers The list of modifiers (public, private, static, const) for the class.
	 * @param containingNamespace The fully qualified name of the namespace this class is declared within.
	 * @return A ClassDeclaration AST node.
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private ClassDeclaration classDeclaration(List<Token> modifiers, String containingNamespace) throws SyntaxError
	{
		Token classKeyword = consume(TokenType.CLASS, "Expected 'class' keyword.");
		Token className = consume(TokenType.IDENTIFIER, "Expected class name.");

		Token extendsKeyword = null;
		Token superClassName = null;
		if(check(TokenType.EXTENDS))
		{
			extendsKeyword = advance();
			superClassName = consume(TokenType.IDENTIFIER, "Expected superclass name after 'extends'.");
		}

		Token leftBrace = consume(TokenType.LEFT_BRACE, "Expected '{' after class name.");

		List<FieldDeclaration> fields = new ArrayList<>();
		List<MethodDeclaration> methods = new ArrayList<>();
		List<ConstructorDeclaration> constructors = new ArrayList<>();

		while(!check(TokenType.RIGHT_BRACE) && !isAtEnd())
		{
			List<Token> memberModifiers = new ArrayList<>();
			while(check(TokenType.PUBLIC) || check(TokenType.PRIVATE) ||
					check(TokenType.STATIC) || check(TokenType.CONST))
			{
				memberModifiers.add(advance());
			}

			Token nextTokenAfterModifiers = peek();

			if(nextTokenAfterModifiers.getType() == TokenType.IDENTIFIER &&
					nextTokenAfterModifiers.getLexeme().equals(className.getLexeme()) &&
					check(1, TokenType.LEFT_PAREN))
			{
				constructors.add(constructorDeclaration(memberModifiers, className));
			}
			else if(isTypeToken(nextTokenAfterModifiers.getType()) &&
					check(1, TokenType.OPERATOR) &&
					isOperatorToken(peek(2).getType()))
			{
				methods.add(methodDeclaration(memberModifiers, true));
			}
			else if(isTypeToken(nextTokenAfterModifiers.getType()) &&
					check(1, TokenType.IDENTIFIER) &&
					check(2, TokenType.LEFT_PAREN))
			{
				methods.add(methodDeclaration(memberModifiers, false));
			}
			else if((isTypeToken(nextTokenAfterModifiers.getType()) || nextTokenAfterModifiers.getType() == TokenType.VAR) &&
					check(1, TokenType.IDENTIFIER) &&
					!check(2, TokenType.LEFT_PAREN))
			{
				fields.add(fieldDeclaration(memberModifiers));
			}
			else
			{
				error(peek(), "Expected field, method, constructor, or operator declaration inside class.");
				synchronizeClassBody();
			}
		}

		Token rightBrace = consume(TokenType.RIGHT_BRACE, "Expected '}' after class body.");

		return new ClassDeclaration(modifiers, classKeyword, className, extendsKeyword, superClassName,
				leftBrace, fields, methods, constructors, rightBrace, containingNamespace);
	}

	/**
	 * Helper to synchronize parsing within a class body in case of an error.
	 * Skips tokens until a known class member start or closing brace.
	 */
	private void synchronizeClassBody()
	{
		advance();

		while(!isAtEnd())
		{
			TokenType type = peek().getType();
			switch(type)
			{
				case PUBLIC:
				case PRIVATE:
				case STATIC:
				case CONST:
				case CLASS:
				case RIGHT_BRACE:
				case OPERATOR:
					return;
				default:
					if(isTypeToken(type) || type == TokenType.VAR)
					{
						if(check(1, TokenType.IDENTIFIER) || (check(1, TokenType.OPERATOR) && isOperatorToken(peek(2).getType())))
						{
							return;
						}
					}
					advance();
			}
		}
	}

	/**
	 * Parses a constructor declaration.
	 * Grammar: `(MODIFIERS)* CLASS_NAME ( (TYPE IDENTIFIER)* ) BLOCK_STATEMENT`
	 *
	 * @param modifiers      List of modifier tokens (e.g., public, private) already consumed.
	 * @param classNameToken The token representing the name of the class (for constructor name validation).
	 * @return A ConstructorDeclaration AST node.
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private ConstructorDeclaration constructorDeclaration(List<Token> modifiers, Token classNameToken) throws SyntaxError
	{
		Token constructorName = consume(TokenType.IDENTIFIER, "Expected constructor name (must match class name).");

		if(!constructorName.getLexeme().equals(classNameToken.getLexeme()))
		{
			errorReporter.report(constructorName.getLine(), constructorName.getColumn(),
					"Constructor name '" + constructorName.getLexeme() + "' does not match class name '" + classNameToken.getLexeme() + "'.");
			throw new SyntaxError();
		}

		consume(TokenType.LEFT_PAREN, "Expected '(' after constructor name.");

		List<Token> parameters = new ArrayList<>();
		if(!check(TokenType.RIGHT_PAREN))
		{
			do
			{
				parameters.add(consume(new TokenType[]{
						TokenType.INT, TokenType.STRING_KEYWORD, TokenType.BOOL, TokenType.FLOAT,
						TokenType.DOUBLE, TokenType.BYTE, TokenType.CHAR, TokenType.IDENTIFIER
				}, "Expected parameter type."));
				parameters.add(consume(TokenType.IDENTIFIER, "Expected parameter name."));
			}
			while(match(TokenType.COMMA));
		}

		consume(TokenType.RIGHT_PAREN, "Expected ')' after parameters.");

		BlockStatement body = blockStatement();
		return new ConstructorDeclaration(modifiers, constructorName, parameters, body);
	}


	/**
	 * Parses a method declaration.
	 * Grammar: (MODIFIERS)* TYPE (IDENTIFIER | 'operator' OPERATOR_TOKEN) '(' (PARAM_LIST)* ')' (BLOCK_STATEMENT | ';')
	 *
	 * @param modifiers          The list of modifiers for the method.
	 * @param isOperatorOverload True if this method is an operator overload declaration.
	 * @return A MethodDeclaration AST node.
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private MethodDeclaration methodDeclaration(List<Token> modifiers, boolean isOperatorOverload) throws SyntaxError
	{
		Token returnType = advance();
		Token methodName;
		Token operatorKeyword = null;

		if(isOperatorOverload)
		{
			operatorKeyword = consume(TokenType.OPERATOR, "Expected 'operator' keyword for operator overloading.");
			methodName = advance();
			if(!isOperatorToken(methodName.getType()))
			{
				throw error(methodName, "Expected an operator symbol after 'operator' keyword.");
			}
		}
		else
		{
			methodName = consume(TokenType.IDENTIFIER, "Expected method name.");
		}


		consume(TokenType.LEFT_PAREN, "Expected '(' after method name or operator.");

		List<Token> parameters = new ArrayList<>();
		if(!check(TokenType.RIGHT_PAREN))
		{
			do
			{
				Token paramType = advance();
				if(!isTypeToken(paramType.getType()))
				{
					throw error(paramType, "Expected parameter type.");
				}
				Token paramName = consume(TokenType.IDENTIFIER, "Expected parameter name.");
				parameters.add(paramType);
				parameters.add(paramName);
			}
			while(match(TokenType.COMMA));
		}

		consume(TokenType.RIGHT_PAREN, "Expected ')' after method parameters.");

		BlockStatement body = null;
		Token semicolon = null;
		if(check(TokenType.LEFT_BRACE))
		{
			body = blockStatement();
		}
		else
		{
			semicolon = consume(TokenType.SEMICOLON, "Expected method body or ';' after method declaration.");
		}

		return new MethodDeclaration(modifiers, returnType, methodName, parameters, body, semicolon, operatorKeyword);
	}

	/**
	 * Helper to check if a TokenType represents an operator that can be overloaded.
	 * This will expand as more operators are supported for overloading.
	 */
	private boolean isOperatorToken(TokenType type)
	{
		switch(type)
		{
			case PLUS:
			case MINUS:
			case STAR:
			case SLASH:
			case MODULO:
			case EQUAL_EQUAL:
			case BANG_EQUAL:
			case LESS:
			case GREATER:
			case LESS_EQUAL:
			case GREATER_EQUAL:
				return true;
			default:
				return false;
		}
	}

	/**
	 * Parses a field declaration.
	 * Grammar: `(MODIFIERS)* TYPE IDENTIFIER ('=' EXPRESSION)? ;`
	 *
	 * @param modifiers List of modifier tokens for the field.
	 * @return A FieldDeclaration AST node.
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private FieldDeclaration fieldDeclaration(List<Token> modifiers) throws SyntaxError
	{
		Token type = advance();
		Token name = consume(TokenType.IDENTIFIER, "Expected field name.");

		Expression initializer = null;
		if(match(TokenType.ASSIGN))
		{
			initializer = expression();
		}

		consume(TokenType.SEMICOLON, "Expected ';' after field declaration.");
		return new FieldDeclaration(modifiers, type, name, initializer);
	}


	/**
	 * Parses a block of statements enclosed in curly braces.
	 * Grammar: `{ STATEMENT* }`
	 *
	 * @return A BlockStatement AST node.
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private BlockStatement blockStatement() throws SyntaxError
	{
		consume(TokenType.LEFT_BRACE, "Expected '{' before block statement.");
		List<Statement> statements = new ArrayList<>();

		while(!check(TokenType.RIGHT_BRACE) && !isAtEnd())
		{
			statements.add(statement());
		}

		consume(TokenType.RIGHT_BRACE, "Expected '}' after block statement.");
		return new BlockStatement(statements);
	}

	/**
	 * Parses a single statement.
	 * This method acts as a dispatcher for different statement types.
	 *
	 * @return A Statement AST node.
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private Statement statement() throws SyntaxError
	{
		if(check(TokenType.LEFT_BRACE))
		{
			return blockStatement();
		}

		List<Token> modifiers = new ArrayList<>();
		while(check(TokenType.CONST) || check(TokenType.PUBLIC) || check(TokenType.PRIVATE) || check(TokenType.STATIC))
		{
			modifiers.add(advance());
		}

		if(isTypeToken(peek().getType()))
		{
			if(check(1, TokenType.IDENTIFIER) && !check(2, TokenType.LEFT_PAREN))
			{
				Token typeToken = advance();
				return variableDeclarationStatement(modifiers, typeToken);
			}
		}

		if(check(TokenType.THIS) && check(1, TokenType.LEFT_PAREN))
		{
			return constructorChainingCallStatement();
		}

		if(match(TokenType.IF))
		{
			return ifStatement();
		}
		if(match(TokenType.WHILE))
		{
			return whileStatement();
		}
		if(match(TokenType.FOR))
		{
			return forStatement();
		}
		if(match(TokenType.RETURN))
		{
			return returnStatement();
		}
		if(match(TokenType.SWITCH))
		{
			return switchStatement();
		}

		if(!modifiers.isEmpty())
		{
			errorReporter.report(peek().getLine(), peek().getColumn(), "Modifiers are only allowed on declarations (variables, fields, methods).");
		}

		return expressionStatement();
	}

	/**
	 * Parses a constructor chaining call (e.g., `this(...)`).
	 * This is a special type of statement that can only appear as the first statement in a constructor.
	 * Grammar: `THIS '(' (EXPRESSION (',' EXPRESSION)*)? ')' ;`
	 *
	 * @return A ConstructorChainingCallStatement AST node.
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private ConstructorChainingCallStatement constructorChainingCallStatement() throws SyntaxError
	{
		Token thisKeyword = consume(TokenType.THIS, "Expected 'this' keyword for constructor call.");
		Token leftParen = consume(TokenType.LEFT_PAREN, "Expected '(' after 'this' for constructor call.");

		List<Expression> arguments = new ArrayList<>();
		if(!check(TokenType.RIGHT_PAREN))
		{
			do
			{
				arguments.add(expression());
			}
			while(match(TokenType.COMMA));
		}
		Token rightParen = consume(TokenType.RIGHT_PAREN, "Expected ')' after constructor call arguments.");
		consume(TokenType.SEMICOLON, "Expected ';' after constructor call.");

		return new ConstructorChainingCallStatement(thisKeyword, leftParen, arguments, rightParen);
	}

	/**
	 * Parses an if statement.
	 * Grammar: `IF '(' EXPRESSION ')' (BLOCK_STATEMENT | STATEMENT) ('else' (BLOCK_STATEMENT | STATEMENT))?`
	 *
	 * @return An IfStatement AST node.
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private IfStatement ifStatement() throws SyntaxError
	{
		Token ifKeyword = previous();

		consume(TokenType.LEFT_PAREN, "Expected '(' after 'if'.");
		Expression condition = expression();
		consume(TokenType.RIGHT_PAREN, "Expected ')' after if condition.");

		Statement thenBranch;
		if(check(TokenType.LEFT_BRACE))
		{
			thenBranch = blockStatement();
		}
		else
		{
			thenBranch = statement();
		}

		Statement elseBranch = null;
		if(match(TokenType.ELSE))
		{
			if(check(TokenType.LEFT_BRACE))
			{
				elseBranch = blockStatement();
			}
			else
			{
				elseBranch = statement();
			}
		}

		return new IfStatement(ifKeyword, condition, thenBranch, elseBranch);
	}

	/**
	 * Parses a while loop statement.
	 * Grammar: `WHILE ( EXPRESSION ) BLOCK_STATEMENT`
	 *
	 * @return A WhileStatement AST node.
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private WhileStatement whileStatement() throws SyntaxError
	{
		consume(TokenType.LEFT_PAREN, "Expected '(' after 'while'.");
		Expression condition = expression();
		consume(TokenType.RIGHT_PAREN, "Expected ')' after while condition.");

		BlockStatement body = blockStatement();
		return new WhileStatement(condition, body);
	}

	/**
	 * Parses a for loop statement.
	 * Grammar: `FOR ( (VAR_DECL | EXPR_STMT | ;) EXPR_STMT ; (EXPRESSION)? ) BLOCK_STATEMENT`
	 * A more robust for loop would parse:
	 * `for ( (variableDeclaration | expressionStatement | ';') expression? ';' expression? ) statement`
	 * For simplicity, this will parse: `for ( VAR_DECL_OR_EXPR ; CONDITION ; INCREMENT ) BLOCK_STATEMENT`
	 *
	 * @return A ForStatement AST node.
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private ForStatement forStatement() throws SyntaxError
	{
		consume(TokenType.LEFT_PAREN, "Expected '(' after 'for'.");

		Statement initializer = null;
		List<Token> initializerModifiers = new ArrayList<>();

		while(check(TokenType.CONST) || check(TokenType.PUBLIC) || check(TokenType.PRIVATE) || check(TokenType.STATIC))
		{
			initializerModifiers.add(advance());
		}

		if(match(TokenType.SEMICOLON))
		{
			// No initializer
		}
		else if(check(TokenType.VAR, TokenType.INT, TokenType.STRING_KEYWORD, TokenType.BOOL, TokenType.FLOAT, TokenType.DOUBLE, TokenType.BYTE, TokenType.CHAR))
		{
			Token typeToken = advance();
			initializer = variableDeclarationStatement(initializerModifiers, typeToken);
		}
		else if(check(TokenType.IDENTIFIER) && check(1, TokenType.IDENTIFIER) && !check(2, TokenType.LEFT_PAREN))
		{
			Token typeToken = advance();
			initializer = variableDeclarationStatement(initializerModifiers, typeToken);
		}
		else
		{
			initializerModifiers.clear();
			initializer = expressionStatement();
		}

		Expression condition = null;
		if(!check(TokenType.SEMICOLON))
		{
			condition = expression();
		}
		consume(TokenType.SEMICOLON, "Expected ';' after for loop condition.");

		Expression increment = null;
		if(!check(TokenType.RIGHT_PAREN))
		{
			increment = expression();
		}
		consume(TokenType.RIGHT_PAREN, "Expected ')' after for loop clauses.");

		BlockStatement body = blockStatement();
		return new ForStatement(initializer, condition, increment, body);
	}


	/**
	 * Parses a return statement.
	 * Grammar: `RETURN (EXPRESSION)? ;`
	 *
	 * @return A ReturnStatement AST node.
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private ReturnStatement returnStatement() throws SyntaxError
	{
		Token returnKeyword = previous();
		Expression value = null;
		if(!check(TokenType.SEMICOLON))
		{
			value = expression();
		}
		consume(TokenType.SEMICOLON, "Expected ';' after return statement.");
		return new ReturnStatement(returnKeyword, value);
	}

	/**
	 * Parses a variable declaration statement. This is the entry point
	 * from `statement()` when modifiers are parsed *before* the type token.
	 * <p>
	 * Grammar: `(MODIFIERS)* (TYPE | VAR) IDENTIFIER (= EXPRESSION)? ;`
	 *
	 * @return A VariableDeclarationStatement AST node.
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private VariableDeclarationStatement variableDeclarationStatement(List<Token> modifiers, Token typeToken) throws SyntaxError
	{
		Token name = consume(TokenType.IDENTIFIER, "Expected variable name.");

		Expression initializer = null;
		if(match(TokenType.ASSIGN))
		{
			initializer = expression();
		}

		consume(TokenType.SEMICOLON, "Expected ';' after variable declaration.");
		return new VariableDeclarationStatement(modifiers, typeToken, name, initializer);
	}


	/**
	 * Parses an expression statement.
	 * Grammar: `EXPRESSION ;`
	 *
	 * @return An ExpressionStatement AST node.
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private ExpressionStatement expressionStatement() throws SyntaxError
	{
		Expression expr = expression();
		consume(TokenType.SEMICOLON, "Expected ';' after expression.");
		return new ExpressionStatement(expr);
	}

	/**
	 * Parses an expression based on operator precedence.
	 * This is a chain of methods, each handling a lower precedence level.
	 * Order of precedence (highest to lowest, then left-associativity):
	 * Assignment -> Logical OR -> Logical AND -> Equality -> Is -> Comparison -> Additive -> Multiplicative -> Unary -> Call/Member Access/Postfix -> Primary
	 *
	 * @return The parsed Expression AST node.
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private Expression expression() throws SyntaxError
	{
		return assignment();
	}

	private Expression assignment() throws SyntaxError
	{
		Expression expr = or();

		if(match(TokenType.ASSIGN, TokenType.PLUS_ASSIGN, TokenType.MINUS_ASSIGN, TokenType.STAR_ASSIGN, TokenType.SLASH_ASSIGN, TokenType.MODULO_ASSIGN))
		{
			Token operator = previous();
			Expression value = assignment();

			if(expr instanceof IdentifierExpression || expr instanceof DotExpression || expr instanceof ArrayAccessExpression)
			{
				return new AssignmentExpression(expr, operator, value);
			}
			else
			{
				errorReporter.report(operator.getLine(), operator.getColumn(), "Invalid assignment target.");
				throw new SyntaxError();
			}
		}
		return expr;
	}

	private Expression or() throws SyntaxError
	{
		Expression expr = and();

		while(match(TokenType.PIPE_PIPE))
		{
			Token operator = previous();
			Expression right = and();
			expr = new BinaryExpression(expr, operator, right);
		}
		return expr;
	}

	private Expression and() throws SyntaxError
	{
		Expression expr = equality();

		while(match(TokenType.AMPERSAND_AMPERSAND))
		{
			Token operator = previous();
			Expression right = equality();
			expr = new BinaryExpression(expr, operator, right);
		}
		return expr;
	}

	private Expression equality() throws SyntaxError
	{
		Expression expr = isExpression();

		while(match(TokenType.BANG_EQUAL, TokenType.EQUAL_EQUAL))
		{
			Token operator = previous();
			Expression right = isExpression();
			expr = new BinaryExpression(expr, operator, right);
		}
		return expr;
	}

	private Expression isExpression() throws SyntaxError
	{
		Expression expr = comparison();

		if(match(TokenType.IS))
		{
			Token isKeyword = previous();
			Token typeToken = consume(new TokenType[]{
					TokenType.INT, TokenType.BOOL, TokenType.CHAR, TokenType.BYTE,
					TokenType.FLOAT, TokenType.DOUBLE, TokenType.STRING_KEYWORD,
					TokenType.IDENTIFIER
			}, "Expected a valid type name (e.g., 'int', 'string', or a class name) after 'is' operator.");
			return new IsExpression(expr, isKeyword, typeToken);
		}
		return expr;
	}

	private Expression comparison() throws SyntaxError
	{
		Expression expr = additive();

		while(match(TokenType.GREATER, TokenType.GREATER_EQUAL, TokenType.LESS, TokenType.LESS_EQUAL))
		{
			Token operator = previous();
			Expression right = additive();
			expr = new BinaryExpression(expr, operator, right);
		}
		return expr;
	}

	private Expression additive() throws SyntaxError
	{
		Expression expr = multiplicative();

		while(match(TokenType.MINUS, TokenType.PLUS))
		{
			Token operator = previous();
			Expression right = multiplicative();
			expr = new BinaryExpression(expr, operator, right);
		}
		return expr;
	}

	private Expression multiplicative() throws SyntaxError
	{
		Expression expr = unary();

		while(match(TokenType.SLASH, TokenType.STAR, TokenType.MODULO))
		{
			Token operator = previous();
			Expression right = unary();
			expr = new BinaryExpression(expr, operator, right);
		}
		return expr;
	}

	/**
	 * Parses unary expressions (e.g., `-x`, `!isTrue`, `++i`, `--j`).
	 * Grammar: `(UNARY_OPERATOR)* CALL`
	 *
	 * @return A UnaryExpression AST node or a higher precedence expression.
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private Expression unary() throws SyntaxError
	{
		if(match(TokenType.BANG, TokenType.MINUS, TokenType.PLUS_PLUS, TokenType.MINUS_MINUS))
		{
			Token operator = previous();
			Expression right = unary();
			return new UnaryExpression(operator, right);
		}
		return call();
	}

	/**
	 * Handles method calls, member access (dot operator), and postfix unary operators.
	 * This method is left-associative for chaining.
	 * Grammar: `PRIMARY ( ( . IDENTIFIER ) | ( ( ARGUMENTS ) ) | ( ++ | -- ) | ( [ EXPRESSION ] ) )*`
	 *
	 * @return The parsed Expression AST node.
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private Expression call() throws SyntaxError
	{
		Expression expr = primary();

		while(true)
		{
			if(match(TokenType.DOT))
			{
				Token dot = previous();
				Token memberName = consume(TokenType.IDENTIFIER, "Expected member name after '.'.");
				expr = new DotExpression(expr, dot, memberName);
			}
			else if(check(TokenType.LEFT_PAREN))
			{
				Token paren = advance();
				List<Expression> arguments = new ArrayList<>();
				if(!check(TokenType.RIGHT_PAREN))
				{
					do
					{
						arguments.add(expression());
					}
					while(match(TokenType.COMMA));
				}
				consume(TokenType.RIGHT_PAREN, "Expected ')' after arguments.");
				expr = new CallExpression(expr, paren, arguments);
			}
			else if(match(TokenType.LEFT_BRACKET))
			{
				Token leftBracket = previous();
				Expression index = expression();
				Token rightBracket = consume(TokenType.RIGHT_BRACKET, "Expected ']' after index expression.");
				expr = new ArrayAccessExpression(expr, index, rightBracket);
			}
			else if(match(TokenType.PLUS_PLUS, TokenType.MINUS_MINUS))
			{
				Token operator = previous();
				if(expr instanceof IdentifierExpression || expr instanceof DotExpression || expr instanceof ArrayAccessExpression)
				{
					expr = new PostfixUnaryExpression(expr, operator);
				}
				else
				{
					errorReporter.report(operator.getLine(), operator.getColumn(), "Invalid target for postfix increment/decrement operator. Must be a variable, property, or array element.");
					throw new SyntaxError();
				}
			}
			else
			{
				break;
			}
		}
		return expr;
	}

	/**
	 * Parses the most basic expressions: literals, identifiers, 'this', parenthesized expressions, and 'new' expressions.
	 * Grammar: `LITERAL | IDENTIFIER | THIS | ( EXPRESSION ) | NEW_EXPRESSION`
	 *
	 * @return The parsed primary Expression AST node.
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private Expression primary() throws SyntaxError
	{
		Token token = peek();
		switch(token.getType())
		{
			case INTEGER_LITERAL:
			case STRING_LITERAL:
			case CHAR_LITERAL:
			case BOOLEAN_LITERAL:
			case FLOAT_LITERAL:
			case DOUBLE_LITERAL:
				Token literalToken = advance();
				return new LiteralExpression(literalToken.getLiteral(), literalToken);
			case IDENTIFIER:
				return new IdentifierExpression(advance());
			case THIS:
				return new ThisExpression(advance());
			case NEW:
				Token newKeyword = advance();
				Expression classNameExpr = qualifiedName();

				Token leftParen = consume(TokenType.LEFT_PAREN, "Expected '(' after class name in 'new' expression.");
				List<Expression> arguments = new ArrayList<>();

				if(!check(TokenType.RIGHT_PAREN))
				{
					do
					{
						arguments.add(expression());
					}
					while(match(TokenType.COMMA));
				}
				Token rightParen = consume(TokenType.RIGHT_PAREN, "Expected ')' after new expression arguments.");
				return new NewExpression(newKeyword, classNameExpr, leftParen, arguments);
			case LEFT_PAREN:
				leftParen = advance();
				Expression expr = expression();
				consume(TokenType.RIGHT_PAREN, "Expected ')' after expression.");
				return new GroupingExpression(leftParen, expr);
			default:
				throw error(peek(), "Expected expression.");
		}
	}


	/**
	 * Consumes the current token if its type matches any of the given types.
	 *
	 * @param types The TokenType(s) to match against.
	 * @return True if a match was found and the token was consumed, false otherwise.
	 */
	private boolean match(TokenType... types)
	{
		for(TokenType type : types)
		{
			if(check(type))
			{
				advance();
				return true;
			}
		}
		return false;
	}

	/**
	 * Checks if the current token is of the expected type without consuming it.
	 * If not, it reports a syntax error and throws a SyntaxError.
	 *
	 * @param type    The expected TokenType.
	 * @param message The error message to report if the type doesn't match.
	 * @return The consumed Token if it matches the expected type.
	 * @throws SyntaxError if the current token's type does not match the expected type.
	 */
	private Token consume(TokenType type, String message) throws SyntaxError
	{
		if(check(type))
		{
			return advance();
		}
		throw error(peek(), message);
	}

	/**
	 * Overloaded consume method to check for multiple expected types.
	 *
	 * @param types   The expected TokenTypes.
	 * @param message The error message to report if the type doesn't match.
	 * @return The consumed Token if it matches one of the expected types.
	 * @throws SyntaxError if the current token's type does not match any of the expected types.
	 */
	private Token consume(TokenType[] types, String message) throws SyntaxError
	{
		for(TokenType type : types)
		{
			if(check(type))
			{
				return advance();
			}
		}
		throw error(peek(), message);
	}

	/**
	 * Checks if the current token's type matches any of the given types.
	 *
	 * @param types The TokenType(s) to check against.
	 * @return True if the current token matches any of the types, false otherwise.
	 */
	private boolean check(TokenType... types)
	{
		if(isAtEnd())
			return false;
		TokenType currentType = peek().getType();
		for(TokenType type : types)
		{
			if(currentType == type)
			{
				return true;
			}
		}
		return false;
	}

	/**
	 * Helper method to check a token type at a given offset from the current position.
	 *
	 * @param offset The offset from the current token (0 for current, 1 for next, etc.)
	 * @param type   The TokenType to check for.
	 * @return True if the token at the offset exists and matches the type, false otherwise.
	 */
	private boolean check(int offset, TokenType type)
	{
		if(current + offset >= tokens.size())
		{
			return false;
		}
		Token tokenAtOffset = tokens.get(current + offset);
		boolean matches = tokenAtOffset.getType() == type;
		return matches;
	}


	/**
	 * Helper method to determine if a TokenType represents a valid type (e.g., int, String, custom class, or 'var').
	 *
	 * @param type The TokenType to check.
	 * @return True if the type is a valid data type (including 'var'), false otherwise.
	 */
	private boolean isTypeToken(TokenType type)
	{
		return type == TokenType.VOID || type == TokenType.STRING_KEYWORD || type == TokenType.INT ||
				type == TokenType.BOOL || type == TokenType.FLOAT || type == TokenType.DOUBLE ||
				type == TokenType.BYTE || type == TokenType.CHAR || type == TokenType.IDENTIFIER || type == TokenType.VAR;
	}

	/**
	 * Consumes the current token and returns it.
	 *
	 * @return The consumed Token.
	 */
	private Token advance()
	{
		if(!isAtEnd())
			current++;
		return previous();
	}

	/**
	 * Looks at the token at a given offset from the current position without consuming it.
	 *
	 * @param offset The offset from the current token (0 for current, 1 for next, etc.).
	 * @return The Token at the specified offset, or EOF if past the end of the token list.
	 */
	private Token peek(int offset)
	{
		if(current + offset >= tokens.size())
		{
			return tokens.get(tokens.size() - 1);
		}
		return tokens.get(current + offset);
	}

	/**
	 * Looks at the current token without consuming it.
	 * (Delegates to peek(0))
	 *
	 * @return The current Token.
	 */
	private Token peek()
	{
		return peek(0);
	}

	/**
	 * Looks at the previous token (the one just consumed).
	 *
	 * @return The previous Token.
	 */
	private Token previous()
	{
		return tokens.get(current - 1);
	}

	/**
	 * Checks if the parser has reached the end of the token stream.
	 *
	 * @return True if at the end, false otherwise.
	 */
	private boolean isAtEnd()
	{
		return peek().getType() == TokenType.EOF;
	}

	/**
	 * Reports a parsing error and creates a SyntaxError.
	 *
	 * @param token   The token where the error occurred.
	 * @param message The error message.
	 * @return A new SyntaxError instance.
	 */
	private SyntaxError error(Token token, String message)
	{
		errorReporter.report(token.getLine(), token.getColumn(), message);
		return new SyntaxError();
	}

	/**
	 * Attempts to synchronize the parser after an error to continue parsing.
	 * This method skips tokens until it finds a likely synchronization point
	 * (e.g., a semicolon, or the start of a new declaration/statement keyword).
	 */
	private void synchronize()
	{
		advance();

		while(!isAtEnd())
		{
			if(previous().getType() == TokenType.SEMICOLON)
				return;
			if(peek().getType() == TokenType.RIGHT_BRACE)
			{
				advance();
				return;
			}

			switch(peek().getType())
			{
				case CLASS:
				case NAMESPACE:
				case PUBLIC:
				case PRIVATE:
				case STATIC:
				case IF:
				case FOR:
				case WHILE:
				case RETURN:
				case IMPORT:
				case GLOBAL:
				case SWITCH:
				case CASE:
				case DEFAULT:
					return;
				default:
			}
			advance();
		}
	}

	/**
	 * Custom exception for handling parsing errors.
	 * This is an unchecked exception, used internally by the parser
	 * to unwind the stack when a syntax error is found.
	 */
	private static class SyntaxError extends RuntimeException
	{
		// No special fields or constructors needed for this basic error type
	}

	/**
	 * Parses a switch statement.
	 * Grammar: `SWITCH ( EXPRESSION ) { ( CASE CONSTANT_EXPRESSION : STATEMENT* )* ( DEFAULT : STATEMENT* )? }`
	 *
	 * @return A SwitchStatement AST node.
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private SwitchStatement switchStatement() throws SyntaxError
	{
		Token switchKeyword = previous();
		consume(TokenType.LEFT_PAREN, "Expected '(' after 'switch'.");
		Expression switchExpr = expression();
		consume(TokenType.RIGHT_PAREN, "Expected ')' after switch expression.");
		consume(TokenType.LEFT_BRACE, "Expected '{' for switch body.");

		List<SwitchCase> cases = new ArrayList<>();
		BlockStatement defaultBlock = null;

		while(!check(TokenType.RIGHT_BRACE) && !isAtEnd())
		{
			if(match(TokenType.CASE))
			{
				cases.add(switchCase());
			}
			else if(match(TokenType.DEFAULT))
			{
				if(defaultBlock != null)
				{
					error(previous(), "A 'default' clause is already defined in this switch statement.");
				}
				Token defaultKeyword = previous();
				consume(TokenType.COLON, "Expected ':' after 'default' keyword.");
				List<Statement> defaultBodyStatements = new ArrayList<>();
				while(!check(TokenType.CASE) && !check(TokenType.DEFAULT) && !check(TokenType.RIGHT_BRACE) && !isAtEnd())
				{
					defaultBodyStatements.add(statement());
				}
				defaultBlock = new BlockStatement(defaultBodyStatements);
			}
			else
			{
				error(peek(), "Expected 'case' or 'default' keyword within a switch statement.");
				synchronize();
			}
		}
		consume(TokenType.RIGHT_BRACE, "Expected '}' to close the switch statement.");
		return new SwitchStatement(switchKeyword, switchExpr, cases, defaultBlock);
	}

	/**
	 * Parses a single 'case' clause within a switch statement.
	 * Grammar: `CASE CONSTANT_EXPRESSION : STATEMENT*`
	 *
	 * @return A SwitchCase AST node.
	 * @throws SyntaxError if a syntax error occurs.
	 */
	private SwitchCase switchCase() throws SyntaxError
	{
		Token caseKeyword = previous();
		Expression caseValue = expression();
		consume(TokenType.COLON, "Expected ':' after 'case' value.");

		List<Statement> caseBodyStatements = new ArrayList<>();
		while(!check(TokenType.CASE) && !check(TokenType.DEFAULT) && !check(TokenType.RIGHT_BRACE) && !isAtEnd())
		{
			caseBodyStatements.add(statement());
		}
		return new SwitchCase(caseKeyword, caseValue, caseBodyStatements);
	}
}

Main.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/Main.java

package com.juanpa.nebula.transpiler;

import com.juanpa.nebula.transpiler.ast.Program;
import com.juanpa.nebula.transpiler.ast.declarations.ImportDirective;
import com.juanpa.nebula.transpiler.ast.declarations.NamespaceDeclaration;
import com.juanpa.nebula.transpiler.codegen.CppGenerator;
import com.juanpa.nebula.transpiler.lexer.NebulaLexer;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.parser.NebulaParser;
import com.juanpa.nebula.transpiler.semantics.SemanticAnalyzer;
import com.juanpa.nebula.transpiler.util.ErrorReporter;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Entry point for the Nebula Transpiler.
 * This Main class orchestrates the lexical, syntactic, and semantic analysis phases,
 * and now handles C++ code generation and saving.
 */
public class Main
{
	public static void main(String[] args)
	{
		Path projectPath;
		if(args.length > 0)
		{
			projectPath = Paths.get(args[0]);
		}
		else
		{
			projectPath = Paths.get("."); // Default to current working directory
			System.out.println("No project path provided. Using default: current working directory ('.').");
		}

		ErrorReporter errorReporter = new ErrorReporter();

		// Determine the base path for Nebula SDK files
		Path nebulaSdkBasePath = projectPath.resolve("sdk");

		List<Path> nebulaFiles = new ArrayList<>();
		try(Stream<Path> stream = Files.walk(nebulaSdkBasePath))
		{
			stream.filter(Files::isRegularFile)
					.filter(p -> p.toString().endsWith(".neb"))
					.forEach(nebulaFiles::add);
		}
		catch(IOException e)
		{
			System.err.println("Error reading Nebula SDK files: " + e.getMessage());
			return;
		}

		if(nebulaFiles.isEmpty())
		{
			System.out.println("Found 0 Nebula files in the SDK path: " + nebulaSdkBasePath);
			return;
		}
		System.out.println("--- Loading Nebula Project from: " + nebulaSdkBasePath + " ---");
		System.out.println("Found " + nebulaFiles.size() + " Nebula files. Processing...");

		// Create a single aggregated Program AST node
		Program fullProgramAST = new Program();

		// First Pass: Lex and Parse all Nebula files to build the ASTs
		// And aggregate them into a single fullProgramAST
		for(Path filePath : nebulaFiles)
		{
			System.out.println("\n--- Processing file: " + filePath.getFileName() + " ---");
			try(InputStream inputStream = Files.newInputStream(filePath))
			{
				String sourceCode = new String(inputStream.readAllBytes(), StandardCharsets.UTF_8);

				// Lexical Analysis
				NebulaLexer lexer = new NebulaLexer(sourceCode, errorReporter);
				List<Token> tokens = lexer.scanTokens();
				if(errorReporter.hasErrors())
				{
					System.out.println("Lexing failed for " + filePath.getFileName() + ".");
					return;
				}
				System.out.println("Lexing completed successfully for " + filePath.getFileName() + ".");

				// Syntactic Analysis
				NebulaParser parser = new NebulaParser(tokens, errorReporter);
				Program currentFileProgram = parser.parse(); // Parse the current file
				if(errorReporter.hasErrors())
				{
					System.out.println("Parsing failed for " + filePath.getFileName() + ".");
					return;
				}
				System.out.println("Parsing completed successfully for " + filePath.getFileName() + ".");

				// Aggregate namespaces and import directives from current file into the full program AST
				for(ImportDirective directive : currentFileProgram.getImportDirectives())
				{
					fullProgramAST.addImportDirective(directive);
				}
				for(NamespaceDeclaration namespaceDecl : currentFileProgram.getNamespaceDeclarations())
				{
					fullProgramAST.addNamespace(namespaceDecl);
				}

			}
			catch(IOException e)
			{
				System.err.println("Error reading file " + filePath + ": " + e.getMessage());
				return;
			}
		}

		// Semantic Analysis Phase
		System.out.println("\n--- Semantic Analysis Phase (Entire Project) ---");
		SemanticAnalyzer semanticAnalyzer = new SemanticAnalyzer(errorReporter);

		// Analyze the aggregated program AST once
		semanticAnalyzer.analyze(fullProgramAST);

		if(errorReporter.hasErrors())
		{
			System.out.println("Semantic analysis finished with errors for the project. Cannot proceed to code generation.");
			return; // Exit if semantic analysis failed
		}
		System.out.println("Semantic analysis completed successfully for the project.");


		// Code Generation Phase
		System.out.println("\n--- Code Generation Phase ---");
		CppGenerator cppGenerator = new CppGenerator(semanticAnalyzer.getDeclaredClasses());
		Map<String, String> generatedCode = cppGenerator.generate(fullProgramAST);

		if(errorReporter.hasErrors())
		{
			System.out.println("Code generation finished with errors. Generated code might be incomplete or incorrect.");
			// Do not return here, allow saving partial code for debugging
		}
		else
		{
			System.out.println("Code generation completed successfully.");
		}


		// Save Generated C++ Files
		Path outputDirPath = projectPath.resolve("out");
		try
		{
			Files.createDirectories(outputDirPath); // Ensure the output directory exists
			System.out.println("\n--- Saving Generated C++ Files to: " + outputDirPath.toAbsolutePath() + " ---");

			for(Map.Entry<String, String> entry : generatedCode.entrySet())
			{
				String fileName = entry.getKey();
				String code = entry.getValue();
				saveToFile(outputDirPath.resolve(fileName), code);
			}

			/*
			// Copy C++ SDK files
			Path cppSdkSourceDir = nebulaSdkBasePath.resolve("cpp");
			if(Files.exists(cppSdkSourceDir) && Files.isDirectory(cppSdkSourceDir))
			{
				copyCppSdkFiles(cppSdkSourceDir, outputDirPath);
			}
			else
			{
				System.out.println("C++ SDK source directory not found: " + cppSdkSourceDir.toAbsolutePath() + ". Skipping SDK file copy.");
			}
			*/

		}
		catch(IOException e)
		{
			System.err.println("Error creating output directory or saving files: " + e.getMessage());
		}

		System.out.println("\nTranspilation process finished.");
	}

	private static void saveToFile(Path filePath, String content)
	{
		try
		{
			Files.write(filePath, content.getBytes(StandardCharsets.UTF_8));
			System.out.println("Saved: " + filePath.getFileName());
		}
		catch(IOException e)
		{
			System.err.println("Error saving generated code to file '" + filePath + "': " + e.getMessage());
		}
	}

	/**
	 * Copies all C++ SDK files from the source directory to the destination directory.
	 *
	 * @param sourceDir The path to the C++ SDK source directory (e.g., "./sdk/cpp").
	 * @param destDir   The path to the destination directory (e.g., "./out").
	 */
	private static void copyCppSdkFiles(Path sourceDir, Path destDir)
	{
		System.out.println("\n--- Copying C++ SDK files from: " + sourceDir.toAbsolutePath() + " to " + destDir.toAbsolutePath() + " ---");
		try(Stream<Path> stream = Files.walk(sourceDir))
		{
			stream.forEach(sourcePath ->
			{
				try
				{
					Path relativePath = sourceDir.relativize(sourcePath);
					Path destinationPath = destDir.resolve(relativePath);

					if(Files.isDirectory(sourcePath))
					{
						Files.createDirectories(destinationPath); // Ensure subdirectories are created
					}
					else
					{
						// Copy file, replacing existing one if it exists
						Files.copy(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);
						System.out.println("Copied: " + sourcePath.getFileName());
					}
				}
				catch(IOException e)
				{
					System.err.println("Error copying file '" + sourcePath + "': " + e.getMessage());
				}
			});
		}
		catch(IOException e)
		{
			System.err.println("Error walking C++ SDK directory '" + sourceDir + "': " + e.getMessage());
		}
		System.out.println("---------------------------------------------------------------------------\n");
	}
}

codegen/CppGenerator.java ommited:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/codegen/CppGenerator.java

package com.juanpa.nebula.transpiler.codegen;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.ast.Program;
import com.juanpa.nebula.transpiler.ast.declarations.*; // Ensure ParameterDeclaration is here
import com.juanpa.nebula.transpiler.ast.expressions.*;
import com.juanpa.nebula.transpiler.ast.statements.*;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.lexer.TokenType;
import com.juanpa.nebula.transpiler.semantics.*; // Import all semantic types (including FieldSymbol if it's there)

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * CppGenerator is responsible for traversing the Abstract Syntax Tree (AST)
 * and generating corresponding C++ source code. It implements the ASTVisitor
 * interface, where each visit method returns a String representing the C++
 * code for that AST node.
 * <p>
 * It relies heavily on the semantic analysis phase to ensure type correctness
 * and symbol information through resolved symbols on AST nodes.
 * This version generates C++ code for each class into separate `.h` and `.cpp` strings,
 * returned in a Map. It also conditionally generates a `main.cpp` based on a detected
 * main entry point.
 */
public class CppGenerator implements ASTVisitor<String>
{
	private StringBuilder currentClassCodeBuilder;
	private StringBuilder currentHeaderCodeBuilder;

	private int indentLevel = 0;

	private ClassSymbol currentClassSymbol;
	private MethodSymbol currentMethodSymbol; // Keep track of current method for return type lookup
	private boolean inStaticContext; // Not explicitly used but kept from original structure
	private String currentNamespacePrefix;

	private final Map<String, String> generatedClassCodeMap;
	private final Map<String, ClassSymbol> declaredClasses;

	private void error(Token token, String message)
	{
		System.err.println("Code Generation Error at " + token.getLine() + ":" + token.getColumn() + ": " + message);
	}

	public CppGenerator(Map<String, ClassSymbol> declaredClasses)
	{
		this.declaredClasses = declaredClasses; // Initialize the new field
		this.currentClassCodeBuilder = null;
		this.currentHeaderCodeBuilder = null;
		this.currentClassSymbol = null;
		this.currentMethodSymbol = null;
		this.inStaticContext = false;
		this.currentNamespacePrefix = "";
		this.generatedClassCodeMap = new HashMap<>();
	}

	public Map<String, String> generate(Program program)
	{
		// First pass to populate the map for classes and headers
		for(NamespaceDeclaration namespaceDecl : program.getNamespaceDeclarations())
		{
			namespaceDecl.accept(this);
		}

		// Check if a main entry point exists before generating main.cpp
		Optional<ClassDeclaration> mainClassOpt = program.getNamespaceDeclarations().stream()
				.flatMap(ns -> ns.getClassDeclarations().stream())
				.filter(cls -> cls.getMethods().stream()
						.anyMatch(m -> m.getName().getLexeme().equals("main") &&
								m.getModifiers().stream().anyMatch(mod -> mod.getType() == TokenType.STATIC) &&
								// Corrected: resolveTypeFromToken expects a Token, m.getReturnType() is already a Token.
								resolveTypeFromToken(m.getReturnType()).equals(PrimitiveType.VOID) &&
								m.getParameters().isEmpty()))
				.findFirst();

		if(mainClassOpt.isPresent())
		{
			ClassDeclaration mainClassDecl = mainClassOpt.get();
			String mainClassFqn = mainClassDecl.getContainingNamespace().isEmpty() ?
					mainClassDecl.getName().getLexeme() :
					mainClassDecl.getContainingNamespace().replace(".", "::") + "::" + mainClassDecl.getName().getLexeme();


			StringBuilder mainCppBuilder = new StringBuilder();

			// Add necessary includes for the main.cpp
			mainCppBuilder.append("#include <iostream>\n");
			mainCppBuilder.append("#include <memory>\n"); // For std::shared_ptr
			mainCppBuilder.append("#include \"nebula/system/Console.h\"\n");
			mainCppBuilder.append("#include \"nebula/core/Object.h\"\n");
			mainCppBuilder.append("#include \"nebula/core/String.h\"\n"); // Ensure String.h is included if needed in main

			// Dynamically include headers for all generated classes in main.cpp if they contain main
			// For simplicity and correctness with the provided example, we'll hardcode includes for
			// core and system classes in main.cpp. If a user-defined class has main, its header
			// would also need to be included.
			// This part of the code is simplified to match the provided C++ Main.cpp where
			// nebula/Main.h pulls in other necessary headers implicitly for compilation.
			// The primary entry point will be Program::Test::main()
			mainCppBuilder.append("\n// Forward declaration of the Nebula entry point class\n");
			mainCppBuilder.append("namespace Program {\n    class Test;\n}\n\n");


			mainCppBuilder.append("// The C++ standard main function, which will call Nebula's main entry point.\n");
			mainCppBuilder.append("int main() {\n");
			mainCppBuilder.append("    Program::Test::main(); // Call the Nebula program's entry point\n");
			mainCppBuilder.append("    return 0;\n");
			mainCppBuilder.append("}\n");

			generatedClassCodeMap.put("main.cpp", mainCppBuilder.toString());
		}
		else
		{
			System.out.println("No static 'main()' method found in any class. Skipping main.cpp generation.");
		}


		return generatedClassCodeMap;
	}

	private void appendLine(String line)
	{
		if(currentClassCodeBuilder == null)
		{
			System.err.println("Error: currentClassCodeBuilder is null. This should be initialized per class in visitClassDeclaration.");
			return;
		}
		for(int i = 0; i < indentLevel; i++)
		{
			currentClassCodeBuilder.append("    ");
		}
		currentClassCodeBuilder.append(line).append("\n");
	}

	private void appendHeaderLine(String line)
	{
		if(currentHeaderCodeBuilder == null)
		{
			System.err.println("Error: currentHeaderCodeBuilder is null. This should be initialized per class in visitClassDeclaration.");
			return;
		}
		for(int i = 0; i < indentLevel; i++)
		{
			currentHeaderCodeBuilder.append("    ");
		}
		currentHeaderCodeBuilder.append(line).append("\n");
	}

	private void indent()
	{
		indentLevel++;
	}

	private void dedent()
	{
		if(indentLevel > 0)
		{
			indentLevel--;
		}
	}

	private Type resolveTypeFromToken(Token typeToken)
	{
		if(typeToken == null)
		{
			return ErrorType.INSTANCE;
		}

		// Handle primitive types directly
		switch(typeToken.getType())
		{
			case INT:
				return PrimitiveType.INT;
			case BOOL:
				return PrimitiveType.BOOL;
			case FLOAT:
				return PrimitiveType.FLOAT;
			case DOUBLE:
				return PrimitiveType.DOUBLE;
			case BYTE:
				return PrimitiveType.BYTE;
			case VOID:
				return PrimitiveType.VOID;
			case CHAR:
				return PrimitiveType.CHAR;
			case STRING_KEYWORD:
				// Special handling for 'string' keyword, mapping to Nebula's String class
				// Assumes that 'declaredClasses' contains the ClassSymbol for "nebula.core.String"
				return new ClassType("nebula.core.String", declaredClasses.get("nebula.core.String"));
			default:
				// For non-primitive types, attempt to resolve from declaredClasses.
				// First, try a direct lookup by the full lexeme (assuming it might be a FQN in some contexts)
				ClassSymbol byFqn = declaredClasses.get(typeToken.getLexeme());
				if(byFqn != null)
				{
					return byFqn.getType();
				}

				// If not found by direct FQN, iterate through declared classes to find a match by simple name
				// or by ending with the simple name (e.g., "Console" matches "Nebula.System.Console")
				String simpleName = typeToken.getLexeme(); // Corrected: use getLexeme()
				for(ClassSymbol classSymbol : declaredClasses.values())
				{
					if(classSymbol.getName().equals(simpleName) || classSymbol.getFqn().endsWith("." + simpleName))
					{
						return classSymbol.getType();
					}
				}

				// If still not found, return ErrorType.
				error(typeToken, "Could not resolve type '" + typeToken.getLexeme() + "' during C++ generation. Semantic analysis might have missed it or code generation context is insufficient.");
				return ErrorType.INSTANCE;
		}
	}


	private String toCppType(Type type)
	{
		if(type instanceof PrimitiveType)
		{
			if(type.equals(PrimitiveType.INT))
				return "int";
			if(type.equals(PrimitiveType.BOOL))
				return "bool";
			if(type.equals(PrimitiveType.FLOAT))
				return "float";
			if(type.equals(PrimitiveType.DOUBLE))
				return "double";
			if(type.equals(PrimitiveType.BYTE))
				return "char"; // Assuming byte maps to char in C++
			if(type.equals(PrimitiveType.CHAR))
				return "char";
			if(type.equals(PrimitiveType.VOID))
				return "void";
		}
		else if(type instanceof ClassType)
		{
			ClassType classType = (ClassType) type;
			// For all Nebula classes (including String and Object), use shared_ptr
			String cppFqn = classType.getFqn().replace(".", "::");
			return "std::shared_ptr<" + cppFqn + ">";
		}
		else if(type instanceof ArrayType)
		{
			ArrayType arrayType = (ArrayType) type;
			// For arrays, use std::vector. If element is a class, it'll be shared_ptr.
			return "std::vector<" + toCppType(arrayType.getElementType()) + ">";
		}
		else if(type instanceof NullType)
		{
			return "decltype(nullptr)"; // Represents the type of 'nullptr'
		}
		else if(type instanceof ErrorType)
		{
			return "/* ERROR_TYPE */ void*"; // Placeholder for unresolved types
		}
		return "void*"; // Default fallback
	}

	// Helper to get the simple class name from a fully qualified name
	private String getSimpleClassName(String fqn) {
		int lastDot = fqn.lastIndexOf('.');
		return lastDot == -1 ? fqn : fqn.substring(lastDot + 1);
	}

	// Corrected: formatCppParameters now takes List<ParameterDeclaration>
	private String formatCppParameters(List<ParameterDeclaration> parameters)
	{
		if(parameters.isEmpty())
		{
			return "";
		}
		StringBuilder sb = new StringBuilder();
		for(int i = 0; i < parameters.size(); i++)
		{
			ParameterDeclaration param = parameters.get(i);
			// ParameterDeclaration.getType() should return a Token, which resolveTypeFromToken expects.
			Type paramType = resolveTypeFromToken(param.getType());
			String cppType = toCppType(paramType);
			// ParameterDeclaration.getName() should return a Token, then get its lexeme.
			String paramName = param.getName().getLexeme();

			// For Nebula class types, pass shared_ptr by const reference to avoid copying smart pointers
			if (paramType instanceof ClassType) {
				sb.append("const ").append(cppType).append("& ").append(paramName);
			} else {
				sb.append(cppType).append(" ").append(paramName);
			}

			if(i < parameters.size() - 1)
			{
				sb.append(", ");
			}
		}
		return sb.toString();
	}


	@Override
	public String visitProgram(Program program)
	{
		// The 'generate' method already orchestrates the namespace and class visits.
		// This method is primarily for AST traversal.
		return null;
	}

	@Override
	public String visitImportDirective(ImportDirective directive)
	{
		// Import directives are handled at the class header generation phase
		// to determine which C++ headers to include. No direct C++ code generation here.
		return null;
	}

	@Override
	public String visitNamespaceDeclaration(NamespaceDeclaration declaration)
	{
		String qualifiedName = "";
		if(declaration.getNameExpression() instanceof IdentifierExpression)
		{
			qualifiedName = ((IdentifierExpression) declaration.getNameExpression()).getName().getLexeme();
		}
		else if(declaration.getNameExpression() instanceof DotExpression)
		{
			qualifiedName = ((DotExpression) declaration.getNameExpression()).accept(this);
		}

		String previousNamespacePrefix = this.currentNamespacePrefix;
		// Update currentNamespacePrefix for nested namespaces
		if (previousNamespacePrefix.isEmpty()) {
			this.currentNamespacePrefix = qualifiedName;
		} else {
			this.currentNamespacePrefix = previousNamespacePrefix + "." + qualifiedName;
		}


		for(ClassDeclaration classDecl : declaration.getClassDeclarations())
		{
			classDecl.accept(this);
		}

		this.currentNamespacePrefix = previousNamespacePrefix; // Restore previous prefix
		return null;
	}

	@Override
	public String visitClassDeclaration(ClassDeclaration declaration)
	{
		currentClassCodeBuilder = new StringBuilder();
		currentHeaderCodeBuilder = new StringBuilder();
		indentLevel = 0;

		String className = declaration.getName().getLexeme();
		String fullClassName = currentNamespacePrefix.isEmpty() ? className : currentNamespacePrefix + "." + className;
		String cppClassName = className; // Simple name for C++ class declaration
		String cppFqn = fullClassName.replace(".", "::"); // Fully qualified C++ name

		ClassSymbol resolvedClassSymbol = null;
		// Corrected: Simplified symbol resolution for the class declaration
		// Assumes the resolved symbol is directly available on the name expression itself.
		Symbol nameExpressionSymbol = declaration.getNameExpression().getResolvedSymbol();
		if (nameExpressionSymbol instanceof ClassSymbol) {
			resolvedClassSymbol = (ClassSymbol) nameExpressionSymbol;
		}

		ClassSymbol previousClassSymbol = this.currentClassSymbol;
		this.currentClassSymbol = resolvedClassSymbol; // Set current class for symbol resolution within methods

		// Determine the C++ superclass name and its corresponding header file to include
		String cppSuperClassForInheritance = "nebula::core::Object"; // Default base class for C++
		String superClassHeaderToInclude = "nebula/core/Object.h";   // Default header for Object

		// Check if the class explicitly extends another class
		if(declaration.getSuperClassName() != null)
		{
			Type superClassType = resolveTypeFromToken(declaration.getSuperClassName());
			if(superClassType instanceof ClassType)
			{
				ClassType castSuperType = (ClassType) superClassType;
				String superFqn = castSuperType.getFqn();

				// Custom handling for core classes
				if(superFqn.equals("nebula.core.Object"))
				{
					cppSuperClassForInheritance = "nebula::core::Object";
					superClassHeaderToInclude = "nebula/core/Object.h";
				}
				else if(superFqn.equals("nebula.core.String"))
				{
					// This case should ideally not happen as String is a leaf class for inheritance in Nebula example
					cppSuperClassForInheritance = "nebula::core::String";
					superClassHeaderToInclude = "nebula/core/String.h";
				}
				else
				{
					// For other custom Nebula classes, derive the C++ FQN and header path
					cppSuperClassForInheritance = superFqn.replace(".", "::");
					// Assuming header path matches package structure: e.g., nebula.util.MyClass -> nebula/util/MyClass.h
					superClassHeaderToInclude = superFqn.replace(".", "/") + ".h";
				}
			}
			// If superClassType is ErrorType or not ClassType, semantic analysis should have caught it.
			// We'll fall back to nebula::core::Object if it's not a valid ClassType.
		}
		// else: Implicitly extends nebula.core.Object, defaults are already set.

		// --- Generate Header (.h) content ---
		appendHeaderLine("// " + fullClassName.replace(".", "/") + ".h");
		appendHeaderLine("#ifndef " + cppFqn.toUpperCase().replace("::", "_").replace(".", "_") + "_H"); // Unique include guard
		appendHeaderLine("#define " + cppFqn.toUpperCase().replace("::", "_").replace(".", "_") + "_H\n"); // Unique include guard

		// Include necessary headers
		// Always include memory for shared_ptr
		appendHeaderLine("#include <memory>");
		// Include the super class header
		appendHeaderLine("#include \"" + superClassHeaderToInclude + "\"");
		// Include String.h if this isn't String.h itself, as String is fundamental
		if (!fullClassName.equals("nebula.core.String")) {
			appendHeaderLine("#include \"nebula/core/String.h\"");
		}
		appendHeaderLine("#include <string>\n"); // For std::string usage (e.g., in String class, or for hashCode/toString return types)
		appendHeaderLine("#include <vector>\n"); // For array types (std::vector)


		// Open namespace in header
		if(!currentNamespacePrefix.isEmpty())
		{
			// Split namespace by '.' and open them nestedly
			String[] namespaces = currentNamespacePrefix.split("\\.");
			for (String ns : namespaces) {
				appendHeaderLine("namespace " + ns + " {");
				indent();
			}
		}

		// Forward declare shared_ptr for this class for mutual dependencies
		appendHeaderLine("class " + cppClassName + ";");
		// Corrected: No direct Ptr suffix using `using` for the class itself in header.
		// The shared_ptr type is used directly in definitions.
		// appendHeaderLine("// Using Ptr suffix for shared_ptr to clearly indicate managed type\n");
		appendHeaderLine("");


		// Class definition in header, use the determined C++ superclass name
		appendHeaderLine("class " + cppClassName + " : public " + cppSuperClassForInheritance + " {");
		indent();

		// Fields (private by default unless public modifier)
		appendHeaderLine("private:");
		indent();
		for(FieldDeclaration fieldDecl : declaration.getFields())
		{
			String cppFieldType = toCppType(resolveTypeFromToken(fieldDecl.getType()));
			String fieldName = fieldDecl.getName().getLexeme();
			// Add underscore suffix for member variables to distinguish from local variables
			appendHeaderLine(cppFieldType + " " + fieldName + "_;");
		}
		dedent();

		// Separate methods by access modifiers
		List<MethodDeclaration> publicMethods = declaration.getMethods().stream()
				.filter(m -> !m.getModifiers().stream().anyMatch(mod -> mod.getType() == TokenType.PRIVATE))
				.toList();
		List<MethodDeclaration> privateMethods = declaration.getMethods().stream()
				.filter(m -> m.getModifiers().stream().anyMatch(mod -> mod.getType() == TokenType.PRIVATE))
				.toList();
		List<ConstructorDeclaration> publicConstructors = declaration.getConstructors().stream()
				.filter(c -> !c.getModifiers().stream().anyMatch(mod -> mod.getType() == TokenType.PRIVATE))
				.toList();
		List<ConstructorDeclaration> privateConstructors = declaration.getConstructors().stream()
				.filter(c -> c.getModifiers().stream().anyMatch(mod -> mod.getType() == TokenType.PRIVATE))
				.toList();

		appendHeaderLine("public:");
		indent();
		// Constructors
		for(ConstructorDeclaration ctorDecl : publicConstructors)
		{
			String cppParams = formatCppParameters(ctorDecl.getParameters());
			appendHeaderLine(cppClassName + "(" + cppParams + ");");
		}
		// Methods
		for(MethodDeclaration methodDecl : publicMethods)
		{
			this.currentMethodSymbol = methodDecl.getResolvedSymbol(); // Set current method symbol for return statement logic
			String cppReturnType = toCppType(resolveTypeFromToken(methodDecl.getReturnType()));
			String methodName = methodDecl.getName().getLexeme();
			String cppParams = formatCppParameters(methodDecl.getParameters());
			String operatorKeyword = methodDecl.getOperatorKeyword() != null ? "operator" : ""; // "operator" for overloaded operators
			String staticModifier = methodDecl.getModifiers().stream().anyMatch(m -> m.getType() == TokenType.STATIC) ? "static " : "";
			// Determine if a method should be virtual (if it overrides or is overridden)
			// Corrected: Access resolved symbol directly from methodDecl if it exists
			String virtualModifier = "";
			if (methodDecl.getResolvedSymbol() != null && methodDecl.getResolvedSymbol().isOverriding()) {
				virtualModifier = "virtual ";
			}


			// Add 'const' for methods that do not modify the object state (e.g., getters, toString, hashCode, length)
			// This check is simplified; a more robust solution would involve semantic analysis tagging const methods.
			boolean isConstMethod = (methodDecl.getModifiers().stream().anyMatch(m -> m.getType() == TokenType.GET) ||
					methodName.equals("toString") || methodName.equals("hashCode") || methodName.equals("length"));
			String constModifier = isConstMethod ? " const" : "";

			appendHeaderLine(staticModifier + virtualModifier + cppReturnType + " " + operatorKeyword + methodName + "(" + cppParams + ")" + constModifier + ";");
			this.currentMethodSymbol = null; // Reset
		}
		dedent();

		if(!privateMethods.isEmpty() || !privateConstructors.isEmpty())
		{
			appendHeaderLine("private:");
			indent();
			// Private Constructors
			for(ConstructorDeclaration ctorDecl : privateConstructors)
			{
				String cppParams = formatCppParameters(ctorDecl.getParameters());
				appendHeaderLine(cppClassName + "(" + cppParams + ");");
			}
			// Private Methods
			for(MethodDeclaration methodDecl : privateMethods)
			{
				this.currentMethodSymbol = methodDecl.getResolvedSymbol(); // Set current method symbol
				String cppReturnType = toCppType(resolveTypeFromToken(methodDecl.getReturnType()));
				String methodName = methodDecl.getName().getLexeme();
				String cppParams = formatCppParameters(methodDecl.getParameters());
				String operatorKeyword = methodDecl.getOperatorKeyword() != null ? "operator" : "";
				String staticModifier = methodDecl.getModifiers().stream().anyMatch(m -> m.getType() == TokenType.STATIC) ? "static " : "";

				// Corrected: Use anyMatch for stream
				boolean isConstMethod = (methodDecl.getModifiers().stream().anyMatch(m -> m.getType() == TokenType.GET) ||
						methodName.equals("toString") || methodName.equals("hashCode") || methodName.equals("length"));
				String constModifier = isConstMethod ? " const" : "";

				appendHeaderLine(staticModifier + cppReturnType + " " + operatorKeyword + methodName + "(" + cppParams + ")" + constModifier + ";");
				this.currentMethodSymbol = null; // Reset
			}
			dedent();
		}

		dedent();
		appendHeaderLine("}; // class " + cppClassName + "\n");

		// Close namespace(s) in header
		if(!currentNamespacePrefix.isEmpty())
		{
			String[] namespaces = currentNamespacePrefix.split("\\.");
			for (int i = namespaces.length - 1; i >= 0; i--) {
				dedent();
				appendHeaderLine("} // namespace " + namespaces[i] + "\n");
			}
		}
		appendHeaderLine("#endif // " + cppFqn.toUpperCase().replace("::", "_").replace(".", "_") + "_H\n");


		// Store the generated header code
		generatedClassCodeMap.put(fullClassName.replace(".", "/") + ".h", currentHeaderCodeBuilder.toString());

		// --- Generate Source (.cpp) content ---
		appendLine("// " + fullClassName.replace(".", "/") + ".cpp");
		appendLine("#include \"" + getSimpleClassName(fullClassName) + ".h\""); // Include its own header
		appendLine("#include <iostream>");      // For std::cout/endl (if still used directly)
		appendLine("#include <utility>");       // For std::move
		appendLine("#include <functional>");    // For std::hash (used in String::hashCode)
		appendLine("#include <sstream>\n");     // For stringstream (used in Object::hashCode)


		// Open namespace for implementation
		if(!currentNamespacePrefix.isEmpty())
		{
			String[] namespaces = currentNamespacePrefix.split("\\.");
			for (String ns : namespaces) {
				appendLine("namespace " + ns + " {");
				indent();
			}
		}

		// Implement Constructors
		for(ConstructorDeclaration ctorDecl : declaration.getConstructors())
		{
			String cppParams = formatCppParameters(ctorDecl.getParameters());
			StringBuilder initializerList = new StringBuilder();

			// Check for constructor chaining (this() or super())
			ConstructorChainingCallStatement chainingCall = null;
			if(ctorDecl.getBody() != null && !ctorDecl.getBody().getStatements().isEmpty())
			{
				Statement firstStmt = ctorDecl.getBody().getStatements().get(0);
				if(firstStmt instanceof ConstructorChainingCallStatement)
				{
					chainingCall = (ConstructorChainingCallStatement) firstStmt;
					// IMPORTANT: Remove the chaining call statement from the body
					// as it's translated to an initializer list.
					// This requires creating a mutable copy of the statements list.
					// A more robust AST design might separate chaining calls from the block.
					// This cast is safe if you ensure the body is a BlockStatement before here
					// or handle other Body types gracefully.
					if (ctorDecl.getBody() instanceof BlockStatement) {
						((BlockStatement) ctorDecl.getBody()).getStatements().remove(0);
					}
				}
			}

			if(chainingCall != null)
			{
				// Translate this() or super() call to C++ initializer list
				initializerList.append(" : ").append(chainingCall.accept(this));
			}
			else
			{
				// Initialize fields without explicit initializers from declaration, but use ctor params
				// This section needs careful handling to initialize _data for String, etc.
				// For now, let's assume default construction or explicit assignment in body.
				// If fields have initializers, they're handled here.
				List<FieldDeclaration> fieldsWithInitializers = declaration.getFields().stream()
						.filter(f -> f.getInitializer() != null)
						.collect(Collectors.toList());

				if(!fieldsWithInitializers.isEmpty())
				{
					initializerList.append(" :");
					for(int i = 0; i < fieldsWithInitializers.size(); i++)
					{
						FieldDeclaration field = fieldsWithInitializers.get(i);
						initializerList.append(" ").append(field.getName().getLexeme()).append("_(").append(field.getInitializer().accept(this)).append(")");
						if(i < fieldsWithInitializers.size() - 1)
						{
							initializerList.append(",");
						}
					}
				}
			}

			appendLine(cppClassName + "::" + cppClassName + "(" + cppParams + ")" + initializerList.toString() + " {");
			indent();
			if(ctorDecl.getBody() != null)
			{
				// Visit the remaining statements in the constructor body
				ctorDecl.getBody().accept(this);
			}
			dedent();
			appendLine("}\n");
		}


		// Implement Methods
		for(MethodDeclaration methodDecl : declaration.getMethods())
		{
			this.currentMethodSymbol = methodDecl.getResolvedSymbol(); // Set current method symbol for return statement logic
			String cppReturnType = toCppType(resolveTypeFromToken(methodDecl.getReturnType()));
			String methodName = methodDecl.getName().getLexeme();
			String cppParams = formatCppParameters(methodDecl.getParameters());
			String cppMethodName = methodName;
			if(methodDecl.getOperatorKeyword() != null)
			{
				cppMethodName = "operator" + methodDecl.getName().getLexeme();
			}

			boolean isConstMethod = (methodDecl.getModifiers().stream().anyMatch(m -> m.getType() == TokenType.GET) ||
					methodName.equals("toString") || methodName.equals("hashCode") || methodName.equals("length"));
			String constModifier = isConstMethod ? " const" : "";


			appendLine(cppReturnType + " " + cppClassName + "::" + cppMethodName + "(" + cppParams + ")" + constModifier + " {");
			indent();
			// Special handling for core Nebula methods (Object::operator==, String::operator==, hashCode, toString, length)
			if (currentClassSymbol.getFqn().equals("nebula.core.Object")) {
				if (methodName.equals("operator==")) {
					// Object::operator== implementation
					appendLine("if (!other) { return false; }");
					appendLine("return this == other.get();"); // Reference equality
				} else if (methodName.equals("hashCode")) {
					// Object::hashCode implementation
					appendLine("std::stringstream ss;");
					appendLine("ss << reinterpret_cast<void*>(this);");
					appendLine("return ss.str();");
				} else if (methodName.equals("toString")) {
					// Object::toString implementation
					appendLine("return hashCode();");
				} else {
					if(methodDecl.getBody() != null) {
						methodDecl.getBody().accept(this);
					} else {
						appendLine("// Method has no body (likely abstract or external)");
					}
				}
			} else if (currentClassSymbol.getFqn().equals("nebula.core.String")) {
				if (methodName.equals("length")) {
					appendLine("return static_cast<int>(_data.length());");
				} else if (methodName.equals("operator+")) {
					// String::operator+ implementation
					appendLine("if (!other) { return std::make_shared<String>(_data); }");
					appendLine("return std::make_shared<String>(_data + other->_data);");
				} else if (methodName.equals("operator==")) {
					// String::operator== implementation (value comparison)
					appendLine("if (!other) { return false; }");
					appendLine("std::shared_ptr<String> otherString = std::dynamic_pointer_cast<String>(other);");
					appendLine("if (!otherString) { return false; }");
					appendLine("return this->_data == otherString->_data;");
				} else if (methodName.equals("toString")) {
					// String::toString implementation
					appendLine("return _data;");
				} else if (methodName.equals("hashCode")) {
					// String::hashCode implementation
					appendLine("return std::to_string(std::hash<std::string>{}(_data));");
				} else {
					if(methodDecl.getBody() != null) {
						methodDecl.getBody().accept(this);
					} else {
						appendLine("// Method has no body (likely abstract or external)");
					}
				}
			} else if (currentClassSymbol.getFqn().equals("nebula.io.Console")) {
				// Special handling for Console methods (wrapping std::cout)
				// The parameter is always a single one for print/println overloads.
				String argName = methodDecl.getParameters().get(0).getName().getLexeme();
				Type argType = resolveTypeFromToken(methodDecl.getParameters().get(0).getType());

				if (argType instanceof ClassType) { // For Object and String
					appendLine("if (" + argName + ") { std::cout << " + argName + "->toString(); } else { std::cout << \"null\"; }");
				} else if (argType.equals(PrimitiveType.BOOL)) {
					appendLine("std::cout << (" + argName + " ? \"true\" : \"false\");");
				} else {
					appendLine("std::cout << " + argName + ";");
				}
				if (methodName.startsWith("println")) { // println variants append endl
					appendLine("std::cout << std::endl;");
				}
			}
			else {
				// Default behavior for other classes: visit method body if it exists
				if(methodDecl.getBody() != null)
				{
					methodDecl.getBody().accept(this);
				}
				else
				{
					appendLine("// Method has no body (likely abstract or external)");
				}
			}
			dedent();
			appendLine("}\n");
			this.currentMethodSymbol = null; // Reset after implementing method
		}

		// Close namespace(s) for implementation
		if(!currentNamespacePrefix.isEmpty())
		{
			String[] namespaces = currentNamespacePrefix.split("\\.");
			for (int i = namespaces.length - 1; i >= 0; i--) {
				dedent();
				appendLine("} // namespace " + namespaces[i] + "\n");
			}
		}

		// Store the generated code for this class in the map
		generatedClassCodeMap.put(fullClassName.replace(".", "/") + ".cpp", currentClassCodeBuilder.toString());

		this.currentClassSymbol = previousClassSymbol; // Restore previous class symbol
		return null;
	}

	@Override
	public String visitConstructorDeclaration(ConstructorDeclaration declaration)
	{
		// This is handled within visitClassDeclaration.
		return null;
	}

	@Override
	public String visitMethodDeclaration(MethodDeclaration declaration)
	{
		// This is handled within visitClassDeclaration.
		return null;
	}

	@Override
	public String visitFieldDeclaration(FieldDeclaration declaration)
	{
		if(declaration.getInitializer() != null)
		{
			return declaration.getInitializer().accept(this);
		}
		return null;
	}

	@Override
	public String visitBlockStatement(BlockStatement statement)
	{
		// Indent within block statements
		indent();
		for(Statement stmt : statement.getStatements())
		{
			String generatedCode = stmt.accept(this);
			if(generatedCode != null && !generatedCode.isEmpty())
			{
				// Append generated code for statements, ensuring semicolons where needed.
				// Expressions statements already handle their semicolons.
				// Variable declarations might also have them.
				appendLine(generatedCode);
			}
		}
		dedent();
		return null;
	}

	@Override
	public String visitExpressionStatement(ExpressionStatement statement)
	{
		String exprCode = statement.getExpression().accept(this);
		return exprCode + ";"; // Always add a semicolon for expression statements
	}

	@Override
	public String visitIfStatement(IfStatement statement)
	{
		String conditionCode = statement.getCondition().accept(this);
		appendLine("if (" + conditionCode + ") {");
		statement.getThenBranch().accept(this);
		if(statement.getElseBranch() != null)
		{
			appendLine("} else {");
			statement.getElseBranch().accept(this);
		}
		appendLine("}");
		return null;
	}

	@Override
	public String visitWhileStatement(WhileStatement statement)
	{
		String conditionCode = statement.getCondition().accept(this);
		appendLine("while (" + conditionCode + ") {");
		statement.getBody().accept(this);
		appendLine("}");
		return null;
	}

	@Override
	public String visitForStatement(ForStatement statement)
	{
		// For loop initializers often include declarations, which might already end with ';'.
		// Need to be careful not to double-add.
		String initializerCode = statement.getInitializer() != null ? statement.getInitializer().accept(this) : "";
		String conditionCode = statement.getCondition() != null ? statement.getCondition().accept(this) : "";
		String incrementCode = statement.getIncrement() != null ? statement.getIncrement().accept(this) : "";

		// Ensure initializer has a semicolon if it's not a VariableDeclarationStatement
		if (statement.getInitializer() instanceof ExpressionStatement) {
			// ExpressionStatement already adds a semicolon
		} else if (statement.getInitializer() instanceof VariableDeclarationStatement) {
			// VariableDeclarationStatement already adds a semicolon
		} else if (!initializerCode.isEmpty() && !initializerCode.endsWith(";")) {
			initializerCode += ";";
		}


		appendLine("for (" + initializerCode + " " + conditionCode + "; " + incrementCode + ") {");
		statement.getBody().accept(this);
		appendLine("}");
		return null;
	}

	@Override
	public String visitReturnStatement(ReturnStatement statement)
	{
		if(statement.getValue() != null)
		{
			// Corrected: Use currentMethodSymbol to get the return type.
			Type returnType = null;
			if (currentMethodSymbol != null) {
				returnType = resolveTypeFromToken(currentMethodSymbol.getReturnTypeToken()); // Assuming getReturnTypeToken() exists
			}

			String returnedValueCode = statement.getValue().accept(this);

			// This is a complex area for a simple code generator without full type propagation here.
			// For now, we assume expressions directly produce the right shared_ptr if it's a class type.
			// The explicit cast/wrapping for return values needs careful semantic analysis.
			return "return " + returnedValueCode + ";";
		}
		return "return;";
	}

	@Override
	public String visitVariableDeclarationStatement(VariableDeclarationStatement statement)
	{
		String cppType;
		Type actualResolvedType = resolveTypeFromToken(statement.getTypeToken());

		String constModifier = statement.getModifiers().stream()
				.anyMatch(m -> m.getType() == TokenType.CONST) ? "const " : "";

		if(statement.getTypeToken().getType() == TokenType.VAR)
		{
			// 'var' in Nebula implies type inference, map to 'auto' in C++
			cppType = "auto";
			if(statement.getInitializer() == null)
			{
				error(statement.getName(), "'var' keyword requires an initializer.");
				return "// ERROR: 'var' used without initializer and no resolved type from semantic analyzer.";
			}
		}
		else
		{
			cppType = toCppType(actualResolvedType);
		}

		StringBuilder declaration = new StringBuilder();
		declaration.append(constModifier).append(cppType).append(" ");
		declaration.append(statement.getName().getLexeme()); // Variable name in C++

		if(statement.getInitializer() != null)
		{
			declaration.append(" = ").append(statement.getInitializer().accept(this));
		}
		else if (actualResolvedType instanceof ClassType) {
			// For Nebula class types, if no initializer, default construct a nullptr shared_ptr
			declaration.append(" = nullptr");
		}
		return declaration.toString() + ";"; // Add semicolon for variable declarations
	}

	@Override
	public String visitSwitchStatement(SwitchStatement statement)
	{
		String switchExprCode = statement.getSwitchExpression().accept(this);
		appendLine("switch (" + switchExprCode + ") {");
		indent();
		for(SwitchCase sc : statement.getCases())
		{
			sc.accept(this);
		}
		if(statement.getDefaultBlock() != null)
		{
			appendLine("default:");
			statement.getDefaultBlock().accept(this);
		}
		dedent();
		appendLine("}");
		return null;
	}

	@Override
	public String visitSwitchCase(SwitchCase switchCase)
	{
		String caseValueCode = switchCase.getValue().accept(this);
		appendLine("case " + caseValueCode + ":");
		indent();
		for(Statement stmt : switchCase.getBody())
		{
			String generatedCode = stmt.accept(this);
			if(generatedCode != null && !generatedCode.isEmpty())
			{
				appendLine(generatedCode);
			}
		}
		appendLine("break;"); // Add break statement for switch cases
		dedent();
		return null;
	}

	@Override
	public String visitConstructorChainingCallStatement(ConstructorChainingCallStatement statement)
	{
		// This method is called to produce the initializer list part of a constructor.
		StringBuilder call = new StringBuilder();
		String keyword = statement.getKeyword().getLexeme();

		List<String> argCodes = statement.getArguments().stream()
				.map(arg -> arg.accept(this))
				.collect(Collectors.toList());

		if(keyword.equals("this"))
		{
			// Call the current class's constructor
			// currentClassSymbol.getName() returns the simple name of the class
			call.append(currentClassSymbol.getName()).append("(");
		}
		else if(keyword.equals("super"))
		{
			// Call the super class's constructor
			String superCppName = "nebula::core::Object"; // Default
			if(currentClassSymbol != null && currentClassSymbol.getType().getSuperClassType() != null)
			{
				ClassType superClassType = currentClassSymbol.getType().getSuperClassType();
				superCppName = superClassType.getFqn().replace(".", "::");
			}
			// Get the simple name for the superclass constructor call if it's not the default Object
			if (superCppName.startsWith("nebula::core::")) {
				superCppName = getSimpleClassName(superCppName.replace("::", ".")); // Convert back to dot for simple name extraction
			}
			call.append(superCppName).append("(");
		}
		call.append(String.join(", ", argCodes)).append(")");

		return call.toString();
	}

	@Override
	public String visitBinaryExpression(BinaryExpression expression)
	{
		String leftCode = expression.getLeft().accept(this);
		String rightCode = expression.getRight().accept(this);
		String operator = expression.getOperator().getLexeme();

		// Determine the resolved type of the left operand to handle string concatenation
		Type leftResolvedType = null;
		// Corrected: More robust type resolution for left operand
		if (expression.getLeft().getResolvedType() != null) { // Assuming getResolvedType() on Expression exists
			leftResolvedType = expression.getLeft().getResolvedType();
		} else if (expression.getLeft() instanceof LiteralExpression litExpr && litExpr.getLiteralToken().getType() == TokenType.STRING_LITERAL) {
			leftResolvedType = new ClassType("nebula.core.String", declaredClasses.get("nebula.core.String"));
		}


		if(operator.equals("+"))
		{
			// If either operand is a Nebula String, perform string concatenation using operator+
			// This assumes operator+ is defined for shared_ptr<String>
			if (leftResolvedType instanceof ClassType && ((ClassType) leftResolvedType).getFqn().equals("nebula.core.String")) {
				return "(" + leftCode + " + " + rightCode + ")";
			}
			// We might need to consider implicit conversions here if one side is not String but can be converted.
			// For now, only explicit String types trigger shared_ptr operator+.
		}


		return "(" + leftCode + " " + operator + " " + rightCode + ")";
	}

	@Override
	public String visitUnaryExpression(UnaryExpression expression)
	{
		String operandCode = expression.getRight().accept(this);
		String operator = expression.getOperator().getLexeme();

		// For prefix increment/decrement, the operator comes before the operand
		if(operator.equals("++") || operator.equals("--"))
		{
			return operator + operandCode;
		}
		// For other unary operators (like negation '-', logical NOT '!')
		return operator + operandCode;
	}

	@Override
	public String visitLiteralExpression(LiteralExpression expression)
	{
		Object value = expression.getValue();
		TokenType type = expression.getLiteralToken().getType();

		if(type == TokenType.STRING_LITERAL)
		{
			// Wrap string literals in std::make_shared<nebula::core::String>
			// Ensure proper escaping for C++ string literals
			return "std::make_shared<nebula::core::String>(\"" + value.toString()
					.replace("\\", "\\\\") // Escape backslashes
					.replace("\"", "\\\"") // Escape double quotes
					.replace("\n", "\\n") // Escape newlines
					.replace("\t", "\\t") + "\")"; // Escape tabs
		}
		else if(type == TokenType.CHAR_LITERAL)
		{
			// Character literals are single quoted in C++
			return "'" + value + "'";
		}
		else if(type == TokenType.BOOLEAN_LITERAL)
		{
			// Boolean literals are lowercase in C++
			return value.toString().toLowerCase();
		}
		else if(value == null && "null".equals(expression.getLiteralToken().getLexeme()))
		{
			return "nullptr";  // C++ null pointer literal
		}
		// For numeric literals, just return their string representation
		return value.toString();
	}

	@Override
	public String visitIdentifierExpression(IdentifierExpression expression)
	{
		Symbol symbol = expression.getResolvedSymbol();
		if(symbol == null)
		{
			// Fallback if symbol is not resolved (should be caught by semantic analysis)
			return expression.getName().getLexeme();
		}

		if(symbol instanceof VariableSymbol varSym) // Use pattern matching for instanceof
		{
			if(varSym.isStatic())
			{
				String ownerClassName = "";
				if(varSym.getOwnerClass() != null)
				{
					ownerClassName = varSym.getOwnerClass().getFqn().replace(".", "::");
				}
				else
				{
					// If ownerClass is null, assume it's a static member of the current class
					if(currentClassSymbol != null)
					{
						ownerClassName = currentClassSymbol.getFqn().replace(".", "::");
					}
				}
				// Access static fields using ScopeResolutionOperator (::)
				return ownerClassName + "::" + varSym.getName() + "_"; // Assuming static fields also get '_'
			}
			// Corrected: Check if it's an instance field by comparing owner class
			else if(varSym.getOwnerClass() == currentClassSymbol) // Check if it's an instance field of the current class
			{
				// Access instance fields using the 'this->' pointer
				return "this->" + varSym.getName() + "_";
			}
			else
			{
				// Local variable or parameter
				return varSym.getName();
			}
		}
		else if(symbol instanceof ClassSymbol)
		{
			// Reference to a class (e.g., `Object.someStaticMethod()`)
			return ((ClassType) symbol.getType()).getFqn().replace(".", "::");
		}
		else if(symbol instanceof MethodSymbol methodSym) // Use pattern matching
		{
			if(methodSym.isStatic())
			{
				if(methodSym.getOwnerClass() != null)
				{
					return methodSym.getOwnerClass().getFqn().replace(".", "::") + "::" + methodSym.getName();
				}
				// If no owner class, it's an error or implicitly current class.
				return methodSym.getName();
			}
			else
			{
				// Instance method reference (e.g., as part of a method group or lambda, not directly called)
				// For direct calls, this is typically handled by DotExpression.
				return methodSym.getName();
			}
		}
		return expression.getName().getLexeme();
	}


	@Override
	public String visitAssignmentExpression(AssignmentExpression expression)
	{
		String targetCode = expression.getTarget().accept(this);
		String valueCode = expression.getValue().accept(this);
		String operator = expression.getOperator().getLexeme();

		// Special handling for string concatenation assignment (e.g., `myString += "abc"`)
		if(operator.equals("+="))
		{
			// Corrected: Use resolved type of the target to confirm it's a String.
			Type targetResolvedType = expression.getTarget().getResolvedType(); // Assuming getResolvedType() on Expression exists
			if (targetResolvedType instanceof ClassType && ((ClassType) targetResolvedType).getFqn().equals("nebula.core.String")) {
				// C++ operator+= for shared_ptr<String> would concatenate.
				// This assumes the `operator+` is defined for `std::shared_ptr<String>`
				// and returns a new `std::shared_ptr<String>`.
				// To simulate `myString += otherString`, it needs to be `myString = *myString + otherString;`
				// or use a custom append method: `targetCode->append(*valueCode);`
				return targetCode + " = *" + targetCode + " + " + valueCode; // Simulates string += operator with shared_ptr
			}
		}
		return targetCode + " " + operator + " " + valueCode;
	}

	@Override
	public String visitCallExpression(CallExpression expr)
	{
		// Corrected: Pass currentMethodSymbol to allow resolution within the callee's context if needed.
		// However, callee itself should be fully resolved before this.
		String calleeCode = expr.getCallee().accept(this); // This will resolve to FQN::methodName or object->methodName

		List<String> args = expr.getArguments().stream()
				.map(arg -> arg.accept(this))
				.collect(Collectors.toList());

		// The calleeCode already contains the fully qualified name (e.g., "nebula::io::Console::print")
		// The `visitDotExpression` and `visitIdentifierExpression` should correctly resolve
		// `Console.print` to `nebula::io::Console::print`.
		return calleeCode + "(" + String.join(", ", args) + ")";
	}

	@Override
	public String visitDotExpression(DotExpression expr)
	{
		String leftCode = expr.getLeft().accept(this); // Code for the object or namespace on the left
		String memberName = expr.getMemberName().getLexeme(); // The member name (field or method)
		Symbol resolvedSymbol = expr.getResolvedSymbol(); // The symbol resolved by semantic analysis

		if(resolvedSymbol instanceof ClassSymbol ||
				(resolvedSymbol instanceof MethodSymbol m && m.isStatic()))
		{
			// Accessing a static member (class or static method) using '::'
			return leftCode + "::" + memberName;
		}

		// Accessing an instance member (field or method) using '->' for shared_ptr
		// Assume all Nebula objects are shared_ptr, hence '->'
		// Also handle built-in methods like 'length' for String and 'size()' for Array.
		if (resolvedSymbol instanceof FieldSymbol fieldSym) { // Corrected: Use pattern matching
			// If it's a field, add the underscore suffix
			return leftCode + "->" + memberName + "_";
		} else if (resolvedSymbol instanceof MethodSymbol methodSym) { // Corrected: Use pattern matching
			// Special handling for String.length() -> std::string::length()
			if (memberName.equals("length") && methodSym.getOwnerClass() != null && methodSym.getOwnerClass().getFqn().equals("nebula.core.String")) { // Corrected: Check ownerClass for FQN
				return leftCode + "->length()"; // Direct call to String's length method
			}
			// For other instance methods, use '->'
			return leftCode + "->" + memberName;
		}
		// Fallback for cases not explicitly handled (should ideally be resolved)
		return leftCode + "->" + memberName;
	}

	@Override
	public String visitThisExpression(ThisExpression expression)
	{
		// 'this' in Nebula maps to 'this' in C++ when accessing instance members
		// For fields, it will be `this->fieldName_`
		return "this";
	}

	@Override
	public String visitNewExpression(NewExpression expression)
	{
		Type classType = getType(expression);

		// Corrected: Check if classType is null first
		if (classType == null || !(classType instanceof ClassType resolvedClassType))
		{
			error(expression.getClassName(), "Could not resolve class for 'new' expression.");
			return "/* ERROR: Could not resolve class for new expression */ nullptr";
		}

		// Convert Nebula FQN (e.g., "nebula.core.Object") to C++ FQN (e.g., "nebula::core::Object")
		String cppFqn = resolvedClassType.getFqn().replace(".", "::");

		// Recursively visit arguments to generate their C++ code
		List<String> argCodes = expression.getArguments().stream()
				.map(arg -> arg.accept(this))
				.collect(Collectors.toList());

		// Generate the std::make_shared call
		return "std::make_shared<" + cppFqn + ">(" + String.join(", ", argCodes) + ")";
	}

	private static Type getType(NewExpression expression)
	{
		Type classType = null;
		// This part correctly attempts to retrieve the resolved ClassSymbol's Type
		// from either an IdentifierExpression (for simple names like "Object")
		// or a DotExpression (for qualified names like "nebula.core.Object").
		if(expression.getClassName() instanceof IdentifierExpression idExpr)
		{
			Symbol classSym = idExpr.getResolvedSymbol();
			if(classSym instanceof ClassSymbol)
				classType = classSym.getType();
		}
		else if(expression.getClassName() instanceof DotExpression dotExpr)
		{
			Symbol classSym = dotExpr.getResolvedSymbol();
			if(classSym instanceof ClassSymbol)
				classType = classSym.getType();
		}
		return classType;
	}

	@Override
	public String visitPostfixUnaryExpression(PostfixUnaryExpression expression)
	{
		String operandCode = expression.getOperand().accept(this);
		String operator = expression.getOperator().getLexeme();

		// For postfix increment/decrement, the operator comes after the operand
		return operandCode + operator;
	}

	@Override
	public String visitArrayAccessExpression(ArrayAccessExpression expression)
	{
		String arrayCode = expression.getArray().accept(this);
		String indexCode = expression.getIndex().accept(this);

		Type arrayResolvedType = null;
		// Corrected: Use getResolvedType() on the expression itself
		if (expression.getArray().getResolvedType() != null) {
			arrayResolvedType = expression.getArray().getResolvedType();
		}

		// Special handling for String character access (Nebula `s[0]` -> C++ `s->operator[](0)`)
		// and for ArrayType where elements are objects (i.e., shared_ptr), still use ->operator[]
		if(arrayResolvedType instanceof ClassType && ((ClassType) arrayResolvedType).getFqn().equals("nebula.core.String"))
		{
			// Access character from a Nebula String object (which is a shared_ptr to nebula::core::String)
			return arrayCode + "->operator[](" + indexCode + ")";
		}
		else if (arrayResolvedType instanceof ArrayType) {
			// For std::vector, use regular [] operator. If elements are objects, the vector will hold shared_ptr.
			return arrayCode + "[" + indexCode + "]";
		}
		// Default for other array-like types
		return arrayCode + "[" + indexCode + "]";
	}

	@Override
	public String visitGroupingExpression(GroupingExpression expression)
	{
		// Enclose the inner expression in parentheses
		return "(" + expression.getExpression().accept(this) + ")";
	}

	@Override
	public String visitIsExpression(IsExpression expression)
	{
		String leftCode = expression.getLeft().accept(this); // The expression whose type is being checked

		Type targetResolvedType = resolveTypeFromToken(expression.getTypeToken()); // The target type to check against

		if(targetResolvedType instanceof ErrorType)
		{
			error(expression.getTypeToken(), "Target type for 'is' expression could not be resolved.");
			return "/* ERROR_IS_EXPRESSION */ false";
		}

		String cppTargetType = toCppType(targetResolvedType);

		// If the target type is a Nebula class (which maps to std::shared_ptr<Class>),
		// use std::dynamic_pointer_cast to simulate Nebula's 'is' behavior.
		if(cppTargetType.startsWith("std::shared_ptr<"))
		{
			// Extract the raw class name from "std::shared_ptr<RawClassName>"
			String rawCppTargetClass = cppTargetType.substring("std::shared_ptr<".length(), cppTargetType.length() - 1);
			return "(std::dynamic_pointer_cast<" + rawCppTargetClass + ">(" + leftCode + ") != nullptr)";
		}
		else
		{
			// For primitive types or raw pointers, use dynamic_cast (though this is less common for 'is' unless casting base pointers).
			// This case might need refinement based on how Nebula handles primitive type 'is' checks.
			// For now, it's a fallback.
			// Corrected: Use static_cast for simpler types, dynamic_cast for polymorphic base-to-derived if needed.
			// Given Nebula's managed object model, dynamic_pointer_cast is the primary mechanism.
			// This else block might imply non-shared_ptr cases, which are rare for Nebula objects.
			return "/* Non-shared_ptr 'is' check. Review if necessary. */ (static_cast<" + cppTargetType + ">(" + leftCode + ") != nullptr)";
		}
	}
}


util/ErrorReporter.java:
[AND the contents]
package com.juanpa.nebula.transpiler.util;

public class ErrorReporter
{
	private boolean hasErrors = false; // Flag to indicate if any errors have been reported

	/**
	 * Reports a transpilation error.
	 *
	 * @param line    The line number where the error occurred.
	 * @param column  The column number where the error occurred.
	 * @param message The error message.
	 */
	public void report(int line, int column, String message)
	{
		System.err.println("[Error] Line " + line + ", Column " + column + ": " + message);
		hasErrors = true;
	}

	/**
	 * Checks if any errors have been reported.
	 *
	 * @return True if errors exist, false otherwise.
	 */
	public boolean hasErrors()
	{
		return hasErrors;
	}

	/**
	 * Resets the error flag.
	 */
	public void reset()
	{
		hasErrors = false;
	}
}
ast/Program.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/ast/Program.java

package com.juanpa.nebula.transpiler.ast;

import com.juanpa.nebula.transpiler.ast.declarations.NamespaceDeclaration;
import com.juanpa.nebula.transpiler.ast.declarations.ImportDirective; // Changed: Import ImportDirective

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * The root AST node representing an entire Nebula program.
 * Contains a list of namespace declarations.
 */
public class Program implements ASTNode
{
	private final List<ImportDirective> importDirectives; // Changed: List of import directives
	private final List<NamespaceDeclaration> namespaceDeclarations; // List of namespace declarations

	public Program()
	{
		this.importDirectives = new ArrayList<>(); // Initialize the list
		this.namespaceDeclarations = new ArrayList<>();
	}

	public List<ImportDirective> getImportDirectives()
	{ // Changed: Getter for import directives
		return Collections.unmodifiableList(importDirectives);
	}

	public void addImportDirective(ImportDirective directive)
	{ // Changed: Add import directive
		this.importDirectives.add(directive);
	}

	public List<NamespaceDeclaration> getNamespaceDeclarations()
	{
		return Collections.unmodifiableList(namespaceDeclarations);
	}

	public void addNamespace(NamespaceDeclaration namespaceDecl)
	{
		this.namespaceDeclarations.add(namespaceDecl);
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitProgram(this);
	}

	@Override
	public String toString()
	{
		StringBuilder sb = new StringBuilder();
		for(ImportDirective directive : importDirectives)
		{
			sb.append(directive.toString()).append("\n");
		}
		if(!importDirectives.isEmpty() && !namespaceDeclarations.isEmpty())
		{
			sb.append("\n"); // Add a newline to separate imports from namespaces
		}
		for(NamespaceDeclaration namespaceDecl : namespaceDeclarations)
		{
			sb.append(namespaceDecl.toString()).append("\n");
		}
		return sb.toString();
	}
}

ast/ASTVisitor.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/ast/ASTVisitor.java

package com.juanpa.nebula.transpiler.ast;

import com.juanpa.nebula.transpiler.ast.declarations.ClassDeclaration;
import com.juanpa.nebula.transpiler.ast.declarations.ConstructorDeclaration;
import com.juanpa.nebula.transpiler.ast.declarations.FieldDeclaration;
import com.juanpa.nebula.transpiler.ast.declarations.MethodDeclaration;
import com.juanpa.nebula.transpiler.ast.declarations.NamespaceDeclaration;
import com.juanpa.nebula.transpiler.ast.declarations.ImportDirective;
import com.juanpa.nebula.transpiler.ast.expressions.*;
import com.juanpa.nebula.transpiler.ast.statements.*;


/**
 * Interface for the Visitor pattern that allows AST traversal.
 * Each `visit` method corresponds to a specific AST node type.
 * The generic type `R` represents the return value type of the `visit` methods.
 * For expressions, `R` would be the expression's type (e.g., `Type` in semantic analysis).
 * For declarations and statements, which do not produce a value, `R` could be `Void`.
 */
public interface ASTVisitor<R>
{
	// --- Directives ---
	R visitImportDirective(ImportDirective directive);

	// --- Declarations ---
	R visitProgram(Program program);

	R visitNamespaceDeclaration(NamespaceDeclaration declaration);

	R visitClassDeclaration(ClassDeclaration declaration);

	R visitMethodDeclaration(MethodDeclaration declaration);

	R visitConstructorDeclaration(ConstructorDeclaration declaration);

	R visitFieldDeclaration(FieldDeclaration declaration);

	// --- Statements ---
	R visitBlockStatement(BlockStatement statement);

	R visitExpressionStatement(ExpressionStatement statement);

	R visitIfStatement(IfStatement statement);

	R visitWhileStatement(WhileStatement statement);

	R visitForStatement(ForStatement statement);

	R visitReturnStatement(ReturnStatement statement);

	R visitVariableDeclarationStatement(VariableDeclarationStatement statement);

	R visitSwitchStatement(SwitchStatement statement); // Added for SwitchStatement

	R visitSwitchCase(SwitchCase switchCase);         // Added for SwitchCase

	R visitConstructorChainingCallStatement(ConstructorChainingCallStatement statement); // NEW

	// --- Expressions ---
	R visitBinaryExpression(BinaryExpression expression);

	R visitUnaryExpression(UnaryExpression expression);

	R visitLiteralExpression(LiteralExpression expression);

	R visitIdentifierExpression(IdentifierExpression expression);

	R visitAssignmentExpression(AssignmentExpression expression);

	R visitCallExpression(CallExpression expression);

	R visitDotExpression(DotExpression expression);

	R visitThisExpression(ThisExpression expression);

	R visitNewExpression(NewExpression expression);

	R visitPostfixUnaryExpression(PostfixUnaryExpression expression);

	R visitArrayAccessExpression(ArrayAccessExpression expression);

	R visitGroupingExpression(GroupingExpression expression);

	R visitIsExpression(IsExpression expression);
}

ast/expressions/CallExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/expressions/CallExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.semantics.Symbol;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * AST node representing a function or method call.
 * Includes the expression representing the callable entity (e.g., identifier, dot expression)
 * and a list of argument expressions.
 */
public class CallExpression implements Expression
{
	private final Expression callee; // The expression being called (e.g., IdentifierExpression, DotExpression)
	private final Token paren;       // The opening parenthesis token (for error reporting)
	private final List<Expression> arguments;

	public CallExpression(Expression callee, Token paren, List<Expression> arguments)
	{
		this.callee = callee;
		this.paren = paren;
		this.arguments = new ArrayList<>(arguments); // Defensive copy
	}

	public Expression getCallee()
	{
		return callee;
	}

	public Token getParen()
	{
		return paren;
	}

	public List<Expression> getArguments()
	{
		return Collections.unmodifiableList(arguments);
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitCallExpression(this);
	}

	@Override
	public String toString()
	{
		StringBuilder sb = new StringBuilder();
		sb.append("(").append(callee);
		sb.append(")"); // Closing parenthesis from parser
		sb.append("("); // Opening parenthesis for arguments
		for(int i = 0; i < arguments.size(); i++)
		{
			sb.append(arguments.get(i));
			if(i < arguments.size() - 1)
			{
				sb.append(", ");
			}
		}
		sb.append(")"); // Closing parenthesis for arguments
		return sb.toString();
	}

	@Override
	public Token getFirstToken()
	{
		return callee.getFirstToken(); // The first token is the first token of the callee expression
	}

	@Override
	public Symbol getResolvedSymbol()
	{
		return null;
	}

	@Override
	public void setResolvedSymbol(Symbol symbol)
	{

	}
}
ast/expressions/UnaryExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/expressions/UnaryExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.semantics.Symbol;

/**
 * AST node representing a unary operation (e.g., !a, -b).
 * It has an operator token and a single operand expression.
 */
public class UnaryExpression implements Expression
{
	private final Token operator; // The unary operator token (e.g., BANG, MINUS)
	private final Expression right; // The operand expression

	public UnaryExpression(Token operator, Expression right)
	{
		this.operator = operator;
		this.right = right;
	}

	public Token getOperator()
	{
		return operator;
	}

	public Expression getRight()
	{
		return right;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitUnaryExpression(this);
	}

	@Override
	public String toString()
	{
		return "(" + operator.getLexeme() + right + ")";
	}

	@Override
	public Token getFirstToken()
	{
		return operator; // The first token of a unary expression is its operator
	}

	@Override
	public Symbol getResolvedSymbol()
	{
		return null;
	}

	@Override
	public void setResolvedSymbol(Symbol symbol)
	{

	}
}
ast/expressions/LiteralExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/expressions/LiteralExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.lexer.TokenType;
import com.juanpa.nebula.transpiler.semantics.Symbol;

/**
 * AST node representing a literal value (e.g., 123, "hello", true, 3.14).
 * Holds the literal value and its corresponding token.
 */
public class LiteralExpression implements Expression
{
	private final Object value; // The actual literal value (e.g., Integer, String, Boolean, Double)
	private final Token literalToken; // The token representing the literal

	public LiteralExpression(Object value, Token literalToken)
	{
		this.value = value;
		this.literalToken = literalToken;
	}

	public Object getValue()
	{
		return value;
	}

	public Token getLiteralToken()
	{
		return literalToken;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitLiteralExpression(this);
	}

	@Override
	public String toString()
	{
		// For string literals, include quotes in the output for clarity
		if(literalToken.getType() == TokenType.STRING_LITERAL)
		{
			return "\"" + value + "\"";
		}
		return value.toString();
	}

	@Override
	public Token getFirstToken()
	{
		return literalToken;
	}

	@Override
	public Symbol getResolvedSymbol()
	{
		return null;
	}

	@Override
	public void setResolvedSymbol(Symbol symbol)
	{

	}
}
ast/expressions/NewExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/ast/expressions/NewExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.lexer.TokenType;
import com.juanpa.nebula.transpiler.semantics.MethodSymbol; // Import MethodSymbol
import com.juanpa.nebula.transpiler.semantics.Symbol;

import java.util.Collections;
import java.util.List;

/**
 * AST node representing an object instantiation expression (e.g., `new MyClass(arg1, arg2)`).
 */
public class NewExpression implements Expression
{
	private final Token newKeyword; // The 'new' keyword token
	private final Expression className; // The class name being instantiated (IdentifierExpression or DotExpression)
	private final Token paren; // The opening parenthesis token for argument list
	private final List<Expression> arguments; // List of arguments passed to the constructor
	private MethodSymbol resolvedConstructor; // Added to store the resolved constructor symbol

	public NewExpression(Token newKeyword, Expression className, Token paren, List<Expression> arguments)
	{
		if(newKeyword.getType() != TokenType.NEW)
		{
			throw new IllegalArgumentException("Token for NewExpression must be 'new'.");
		}
		if(paren.getType() != TokenType.LEFT_PAREN)
		{
			throw new IllegalArgumentException("Token for NewExpression's parenthesis must be '('.");
		}
		this.newKeyword = newKeyword;
		this.className = className;
		this.paren = paren;
		this.arguments = Collections.unmodifiableList(arguments);
	}

	public Token getNewKeyword()
	{
		return newKeyword;
	}

	public Expression getClassName()
	{
		return className;
	}

	public Token getParen()
	{
		return paren;
	}

	public List<Expression> getArguments()
	{
		return arguments;
	}

	// Getter for resolved constructor
	public MethodSymbol getResolvedConstructor()
	{
		return resolvedConstructor;
	}

	// Setter for resolved constructor
	public void setResolvedConstructor(MethodSymbol resolvedConstructor)
	{
		this.resolvedConstructor = resolvedConstructor;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitNewExpression(this);
	}

	@Override
	public String toString()
	{
		StringBuilder sb = new StringBuilder();
		sb.append(newKeyword.getLexeme()).append(" ");
		sb.append(className.toString());
		sb.append("(");
		for(int i = 0; i < arguments.size(); i++)
		{
			sb.append(arguments.get(i).toString());
			if(i < arguments.size() - 1)
			{
				sb.append(", ");
			}
		}
		sb.append(")");
		return sb.toString();
	}

	@Override
	public Token getFirstToken()
	{
		return newKeyword;
	}

	@Override
	public Symbol getResolvedSymbol()
	{
		return null;
	}

	@Override
	public void setResolvedSymbol(Symbol symbol)
	{

	}
}

ast/expressions/DotExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/expressions/DotExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.semantics.Symbol; // Import Symbol

/**
 * AST node representing a member access expression (e.g., object.property, Namespace.Class.staticMethod).
 * It has a left-hand side expression (the object/namespace) and an identifier for the member.
 */
public class DotExpression implements Expression
{
	private final Expression left; // The left-hand side (e.g., IdentifierExpression for object, DotExpression for qualified name)
	private final Token dotToken; // The dot operator token
	private final Token memberName; // The identifier token for the member name (field, method, nested class)

	// Semantic information to be filled during semantic analysis
	private Symbol resolvedSymbol;

	public DotExpression(Expression left, Token dotToken, Token memberName)
	{
		this.left = left;
		this.dotToken = dotToken;
		this.memberName = memberName;
	}

	public Expression getLeft()
	{
		return left;
	}

	public Token getDotToken()
	{
		return dotToken;
	}

	public Token getMemberName()
	{
		return memberName;
	}

	@Override
	public Symbol getResolvedSymbol()
	{
		return resolvedSymbol;
	}

	@Override
	public void setResolvedSymbol(Symbol resolvedSymbol)
	{
		this.resolvedSymbol = resolvedSymbol;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitDotExpression(this);
	}

	@Override
	public String toString()
	{
		// Example: ((Com.MyCompany).App) or (obj.field)
		return "(" + left + "." + memberName.getLexeme() + ")";
	}

	@Override
	public Token getFirstToken()
	{
		return left.getFirstToken(); // The first token is the first token of the left expression
	}
}

ast/expressions/BinaryExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/expressions/BinaryExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.semantics.Symbol;

/**
 * AST node representing a binary operation (e.g., a + b, x == y, c && d).
 * It has a left operand, an operator token, and a right operand.
 */
public class BinaryExpression implements Expression {
	private final Expression left;
	private final Token operator; // The binary operator token (e.g., PLUS, MINUS, EQUAL_EQUAL)
	private final Expression right;

	public BinaryExpression(Expression left, Token operator, Expression right) {
		this.left = left;
		this.operator = operator;
		this.right = right;
	}

	public Expression getLeft() {
		return left;
	}

	public Token getOperator() {
		return operator;
	}

	public Expression getRight() {
		return right;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor) {
		return visitor.visitBinaryExpression(this);
	}

	@Override
	public String toString() {
		return "(" + left + " " + operator.getLexeme() + " " + right + ")";
	}

	@Override
	public Token getFirstToken() {
		return left.getFirstToken(); // The first token of a binary expression is its left operand's first token
	}

	@Override
	public Symbol getResolvedSymbol()
	{
		return null;
	}

	@Override
	public void setResolvedSymbol(Symbol symbol)
	{

	}
}
ast/expressions/IdentifierExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/expressions/IdentifierExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.lexer.TokenType;
import com.juanpa.nebula.transpiler.semantics.Symbol; // Import Symbol

/**
 * AST node representing an identifier (e.g., a variable name, class name, method name).
 */
public class IdentifierExpression implements Expression
{
	private final Token name; // The IDENTIFIER token
	private Symbol resolvedSymbol; // Added field for resolved symbol

	public IdentifierExpression(Token name)
	{
		if(name.getType() != TokenType.IDENTIFIER)
		{
			throw new IllegalArgumentException("Token for IdentifierExpression must be an IDENTIFIER.");
		}
		this.name = name;
	}

	public Token getName()
	{
		return name;
	}

	// Getter for resolved symbol
	public Symbol getResolvedSymbol()
	{
		return resolvedSymbol;
	}

	// Setter for resolved symbol
	public void setResolvedSymbol(Symbol resolvedSymbol)
	{
		this.resolvedSymbol = resolvedSymbol;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitIdentifierExpression(this);
	}

	@Override
	public String toString()
	{
		return name.getLexeme();
	}

	@Override
	public Token getFirstToken()
	{
		return name;
	}
}
ast/expressions/Expression.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/ast/expressions/Expression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTNode;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.semantics.Symbol; // <-- ADD THIS IMPORT

/**
 * Base interface for all expression nodes in the Abstract Syntax Tree (AST).
 * Expressions are parts of the program that produce a value.
 */
public interface Expression extends ASTNode
{
	/**
	 * Returns the first token that constitutes this expression.
	 * Useful for error reporting to pinpoint the exact location of a semantic error.
	 *
	 * @return The first Token of this expression.
	 */
	Token getFirstToken();

	/**
	 * Retrieves the symbol that this expression was resolved to during semantic analysis.
	 *
	 * @return The resolved Symbol, or null if not yet resolved or not applicable.
	 */
	Symbol getResolvedSymbol();

	/**
	 * Sets the resolved symbol for this expression. This is called by the SemanticAnalyzer.
	 *
	 * @param symbol The symbol that this expression resolves to.
	 */
	void setResolvedSymbol(Symbol symbol);
}
ast/expressions/IsExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/ast/expressions/IsExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.semantics.Symbol;

/**
 * AST node for the 'is' type-checking operator (e.g., `expr is Type`).
 */
public class IsExpression implements Expression
{
	private final Expression left;
	private final Token isKeyword; // The 'is' keyword token
	private final Token typeToken; // The token representing the type (e.g., IDENTIFIER for class, or primitive keyword)

	public IsExpression(Expression left, Token isKeyword, Token typeToken)
	{
		this.left = left;
		this.isKeyword = isKeyword;
		this.typeToken = typeToken;
	}

	public Expression getLeft()
	{
		return left;
	}

	public Token getIsKeyword()
	{
		return isKeyword;
	}

	public Token getTypeToken()
	{
		return typeToken;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		// This will call visitor.visitIsExpression(this)
		return visitor.visitIsExpression(this);
	}

	@Override
	public Token getFirstToken()
	{
		return left.getFirstToken();
	}

	@Override
	public Symbol getResolvedSymbol()
	{
		return null;
	}

	@Override
	public void setResolvedSymbol(Symbol symbol)
	{

	}

	@Override
	public String toString()
	{
		return "(" + left.toString() + " is " + typeToken.getLexeme() + ")";
	}
}
ast/expressions/GroupingExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/ast/expressions/GroupingExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.lexer.TokenType;
import com.juanpa.nebula.transpiler.semantics.Symbol;

/**
 * AST node representing a grouped expression, enclosed in parentheses (e.g., `(a + b)`).
 * This node is primarily used to enforce operator precedence.
 */
public class GroupingExpression implements Expression
{
	private final Expression expression; // The inner expression being grouped
	private final Token leftParen;      // The opening parenthesis token

	/**
	 * Constructs a new GroupingExpression.
	 *
	 * @param leftParen  The opening parenthesis token.
	 * @param expression The inner expression enclosed by the parentheses.
	 */
	public GroupingExpression(Token leftParen, Expression expression)
	{
		if(leftParen.getType() != TokenType.LEFT_PAREN)
		{
			throw new IllegalArgumentException("Token for GroupingExpression must be TokenType.LEFT_PAREN.");
		}
		this.leftParen = leftParen;
		this.expression = expression;
	}

	public Expression getExpression()
	{
		return expression;
	}

	public Token getLeftParen()
	{
		return leftParen;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitGroupingExpression(this);
	}

	@Override
	public String toString()
	{
		return "(" + expression.toString() + ")";
	}

	@Override
	public Token getFirstToken()
	{
		return leftParen; // The opening parenthesis is the first token of the grouping expression
	}

	@Override
	public Symbol getResolvedSymbol()
	{
		return null;
	}

	@Override
	public void setResolvedSymbol(Symbol symbol)
	{

	}
}

ast/expressions/ArrayAccessExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/ast/expressions/ArrayAccessExpression.java
package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.semantics.Symbol;

// Corrected to implement the Expression interface
public class ArrayAccessExpression implements Expression
{
	private final Expression array; // The expression representing the array/string
	private final Expression index; // The expression representing the index
	private final Token rightBracket; // The ']' token
	private Symbol resolvedSymbol;

	public ArrayAccessExpression(Expression array, Expression index, Token rightBracket)
	{
		// No super() call needed as Expression is an interface
		this.array = array;
		this.index = index;
		this.rightBracket = rightBracket;
	}

	public Expression getArray()
	{
		return array;
	}

	public Expression getIndex()
	{
		return index;
	}

	public Token getRightBracket()
	{
		return rightBracket;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitArrayAccessExpression(this);
	}

	@Override
	public Token getFirstToken()
	{
		// The first token of an ArrayAccessExpression is the first token of the array expression
		return array.getFirstToken();
	}

	@Override
	public Symbol getResolvedSymbol()
	{
		return resolvedSymbol;
	}

	@Override
	public void setResolvedSymbol(Symbol symbol)
	{
		resolvedSymbol = symbol;
	}
}
ast/expressions/PostfixUnaryExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/expressions/PostfixUnaryExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.semantics.Symbol;

/**
 * AST node representing a postfix unary operation (e.g., x++, y--).
 * It has an operand expression and a postfix operator token.
 */
public class PostfixUnaryExpression implements Expression
{
	private final Expression operand; // The expression being operated on (must be assignable)
	private final Token operator;    // The postfix operator token (e.g., PLUS_PLUS, MINUS_MINUS)

	public PostfixUnaryExpression(Expression operand, Token operator)
	{
		this.operand = operand;
		this.operator = operator;
	}

	public Expression getOperand()
	{
		return operand;
	}

	public Token getOperator()
	{
		return operator;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitPostfixUnaryExpression(this);
	}

	@Override
	public String toString()
	{
		return "(" + operand + operator.getLexeme() + ")";
	}

	@Override
	public Token getFirstToken()
	{
		return operand.getFirstToken(); // The first token is the first token of the operand
	}

	@Override
	public Symbol getResolvedSymbol()
	{
		return null;
	}

	@Override
	public void setResolvedSymbol(Symbol symbol)
	{

	}
}
ast/expressions/ThisExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/expressions/ThisExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.lexer.TokenType;
import com.juanpa.nebula.transpiler.semantics.Symbol; // Import Symbol

/**
 * AST node representing the 'this' keyword.
 * Represents a reference to the current instance of the class.
 */
public class ThisExpression implements Expression
{
	private final Token keyword; // The 'this' keyword token
	private Symbol resolvedSymbol; // NEW: Added field for resolved symbol

	public ThisExpression(Token keyword)
	{
		if(keyword.getType() != TokenType.THIS)
		{
			throw new IllegalArgumentException("Keyword for ThisExpression must be TokenType.THIS.");
		}
		this.keyword = keyword;
	}

	public Token getKeyword()
	{
		return keyword;
	}

	// NEW: Getter for resolved symbol
	@Override
	public Symbol getResolvedSymbol()
	{
		return resolvedSymbol;
	}

	// NEW: Setter for resolved symbol
	@Override
	public void setResolvedSymbol(Symbol resolvedSymbol)
	{
		this.resolvedSymbol = resolvedSymbol;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitThisExpression(this);
	}

	@Override
	public String toString()
	{
		return "this";
	}

	@Override
	public Token getFirstToken()
	{
		return keyword; // The 'this' keyword itself is the first token
	}
}

ast/expressions/AssignmentExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/expressions/AssignmentExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.lexer.TokenType;
import com.juanpa.nebula.transpiler.semantics.Symbol;

/**
 * AST node representing an assignment operation (e.g., x = 10, obj.property = value, x += 5).
 * It holds the target expression (what's being assigned to), the operator, and the value expression.
 */
public class AssignmentExpression implements Expression
{
	private final Expression target; // The left-hand side of the assignment (e.g., IdentifierExpression, DotExpression)
	private final Token operator;    // The assignment operator token (e.g., ASSIGN, PLUS_ASSIGN, MINUS_ASSIGN)
	private final Expression value;  // The right-hand side expression

	/**
	 * Constructor for AssignmentExpression.
	 *
	 * @param target   The expression representing the target of the assignment.
	 * @param operator The assignment operator token.
	 * @param value    The expression whose value is being assigned.
	 */
	public AssignmentExpression(Expression target, Token operator, Expression value)
	{
		// Basic validation for the operator type (can be expanded)
		if(!isAssignmentOperator(operator.getType()))
		{
			throw new IllegalArgumentException("Invalid token type for assignment operator: " + operator.getType());
		}
		this.target = target;
		this.operator = operator;
		this.value = value;
	}

	private boolean isAssignmentOperator(TokenType type)
	{
		return type == TokenType.ASSIGN || type == TokenType.PLUS_ASSIGN ||
				type == TokenType.MINUS_ASSIGN || type == TokenType.STAR_ASSIGN ||
				type == TokenType.SLASH_ASSIGN || type == TokenType.MODULO_ASSIGN;
	}

	public Expression getTarget()
	{
		return target;
	}

	public Token getOperator()
	{
		return operator;
	}

	public Expression getValue()
	{
		return value;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitAssignmentExpression(this);
	}

	@Override
	public String toString()
	{
		return "(" + target + " " + operator.getLexeme() + " " + value + ")";
	}

	@Override
	public Token getFirstToken()
	{
		return target.getFirstToken(); // The first token is the first token of the target expression
	}

	@Override
	public Symbol getResolvedSymbol()
	{
		return null;
	}

	@Override
	public void setResolvedSymbol(Symbol symbol)
	{

	}
}
ast/ASTNode.java:
[AND the contents]
package com.juanpa.nebula.transpiler.ast;

/**
 * Base interface for all nodes in the Abstract Syntax Tree (AST).
 * All elements that form the structured representation of the program
 * will implement this interface.
 */
public interface ASTNode
{
	/**
	 * Accepts an ASTVisitor to traverse this node.
	 * This is part of the Visitor design pattern, allowing operations to be
	 * performed on the AST nodes without modifying the node classes themselves.
	 *
	 * @param visitor The ASTVisitor instance.
	 * @param <R>     The return type of the visitor's visit methods.
	 * @return The result of the visitor's operation.
	 */
	<R> R accept(ASTVisitor<R> visitor);
}

ast/declarations/MethodDeclaration.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/declarations/MethodDeclaration.java

package com.juanpa.nebula.transpiler.ast.declarations;

import com.juanpa.nebula.transpiler.ast.ASTNode;
import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.ast.statements.BlockStatement;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.lexer.TokenType; // Needed for TokenType reference

import java.util.ArrayList;
import java.util.Collections; // Needed for unmodifiableList
import java.util.List;
import java.util.stream.Collectors;

/**
 * AST node representing a method declaration within a class.
 * This includes the method's name (or operator symbol), return type, parameters, and its body (a block statement or semicolon).
 */
public class MethodDeclaration implements ASTNode
{
	private final List<Token> modifiers; // e.g., PUBLIC, STATIC
	private final Token returnType;      // e.g., VOID, INT, String, IDENTIFIER for custom types
	private final Token name;            // IDENTIFIER token for the method name, OR operator token (e.g., PLUS, EQUAL_EQUAL)
	private final Token operatorKeyword; // The 'operator' keyword token, null if not an overload
	private final List<Token> parameters; // Type, Name, Type, Name...
	private final BlockStatement body;   // The method's code block (null if semicolon present)
	private final Token semicolon;       // The ';' token (null if block body present)

	// Constructor for regular methods (no operatorKeyword, must have body OR semicolon)
	public MethodDeclaration(List<Token> modifiers, Token returnType, Token name,
							 List<Token> parameters, BlockStatement body, Token semicolon)
	{
		// Delegate to the more comprehensive constructor, passing null for operatorKeyword
		this(modifiers, returnType, name, parameters, body, semicolon, null);
	}

	/**
	 * Comprehensive constructor for MethodDeclaration, used by the parser.
	 * @param modifiers The list of modifiers for the method.
	 * @param returnType The return type token.
	 * @param name The method name identifier token or the operator symbol token.
	 * @param parameters List of parameter tokens (type, name, type, name...).
	 * @param body The block statement for the method body (null if semicolon present).
	 * @param semicolon The semicolon token (null if body present).
	 * @param operatorKeyword The 'operator' keyword token (null for regular methods).
	 */
	public MethodDeclaration(List<Token> modifiers, Token returnType, Token name,
							 List<Token> parameters, BlockStatement body, Token semicolon,
							 Token operatorKeyword) // NEW PARAMETER
	{
		this.modifiers = new ArrayList<>(modifiers); // Make a copy
		this.returnType = returnType;
		this.name = name;
		this.parameters = new ArrayList<>(parameters); // Make a copy
		this.body = body;
		this.semicolon = semicolon;
		this.operatorKeyword = operatorKeyword; // Assign the new field

		// Basic validation (optional, can be done in semantic analysis too)
		if (body == null && semicolon == null) {
			throw new IllegalArgumentException("MethodDeclaration must have either a body or a semicolon.");
		}
		if (body != null && semicolon != null) {
			throw new IllegalArgumentException("MethodDeclaration cannot have both a body and a semicolon.");
		}
		// If it's a regular method, name should be IDENTIFIER. If operator, name is operator token.
		if (operatorKeyword == null && name.getType() != TokenType.IDENTIFIER) {
			throw new IllegalArgumentException("Regular method name must be an IDENTIFIER token.");
		}
	}

	public List<Token> getModifiers()
	{
		return Collections.unmodifiableList(modifiers);
	}

	public Token getReturnType()
	{
		return returnType;
	}

	public Token getName()
	{
		return name;
	}

	// NEW: Getter for operatorKeyword
	public Token getOperatorKeyword() {
		return operatorKeyword;
	}

	public List<Token> getParameters()
	{
		return Collections.unmodifiableList(parameters);
	}

	public BlockStatement getBody()
	{
		return body;
	}

	public Token getSemicolon()
	{
		return semicolon;
	}


	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		String mods = modifiers.isEmpty() ? "" : modifiers.stream()
				.map(Token::getLexeme)
				.collect(Collectors.joining(" ")) + " ";
		sb.append(mods).append(returnType.getLexeme()).append(" ");

		if (operatorKeyword != null) { // Handle operator overloading in toString
			sb.append(operatorKeyword.getLexeme()).append(name.getLexeme()); // e.g., "operator+"
		} else {
			sb.append(name.getLexeme());
		}

		sb.append("(").append(formatParameters(parameters)).append(")");
		if(body != null)
		{
			sb.append(" {\n");
			sb.append(indent(body.toString(), 1)); // Indent the body
			sb.append("}\n");
		}
		else if (semicolon != null)
		{
			sb.append(";\n");
		}
		return sb.toString();
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor) {
		return visitor.visitMethodDeclaration(this);
	}

	private String formatParameters(List<Token> params) {
		if (params.isEmpty()) return "";
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < params.size(); i += 2) { // Assuming pairs of (type, name)
			sb.append(params.get(i).getLexeme()).append(" ").append(params.get(i+1).getLexeme());
			if (i + 2 < params.size()) {
				sb.append(", ");
			}
		}
		return sb.toString();
	}

	private String indent(String text, int level) {
		StringBuilder indentedText = new StringBuilder();
		String prefix = "  ".repeat(level);
		// Split by newline and append prefix to each line
		for (String line : text.split("\\R")) { // Use \\R for any Unicode newline
			indentedText.append(prefix).append(line).append("\n");
		}
		return indentedText.toString();
	}

	public Token getFirstToken() {
		// Return the first modifier if present, otherwise the return type token, or operatorKeyword if present.
		if (!modifiers.isEmpty()) {
			return modifiers.get(0);
		}
		if (operatorKeyword != null) {
			return operatorKeyword; // If it's an operator overload and no modifiers
		}
		return returnType; // Default to return type token
	}
}
ast/declarations/ClassDeclaration.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/ast/declarations/ClassDeclaration.java

package com.juanpa.nebula.transpiler.ast.declarations;

import com.juanpa.nebula.transpiler.ast.ASTNode;
import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.ast.expressions.IdentifierExpression;
import com.juanpa.nebula.transpiler.lexer.Token;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * AST node representing a class declaration.
 * Holds the class's name, its modifiers, optional superclass, and lists of its members (fields, constructors, methods).
 */
public class ClassDeclaration implements ASTNode
{
	private final Token name;
	private final List<Token> modifiers; // e.g., PUBLIC, PRIVATE, STATIC, etc.
	private final Token classKeyword; // The 'class' keyword token itself
	private final Token extendsKeyword; // The 'extends' keyword token, null if no extends clause
	private final Token superClassName; // The superclass name token, null if no extends clause
	private final Token leftBrace; // The '{' token opening the class body
	private final Token rightBrace; // The '}' token closing the class body

	private final List<FieldDeclaration> fields;
	private final List<ConstructorDeclaration> constructors;
	private final List<MethodDeclaration> methods;

	// NEW: Field to store the fully qualified name of the containing namespace
	private String containingNamespace;

	// Original constructor (keep for compatibility if needed elsewhere, but typically won't be used by parser)
	public ClassDeclaration(Token name)
	{
		this.name = name;
		this.modifiers = new ArrayList<>();
		this.classKeyword = null; // Default to null for this constructor
		this.extendsKeyword = null;
		this.superClassName = null;
		this.leftBrace = null;
		this.rightBrace = null;
		this.fields = new ArrayList<>();
		this.constructors = new ArrayList<>();
		this.methods = new ArrayList<>();
		this.containingNamespace = ""; // Initialize to empty string by default
	}

	/**
	 * Comprehensive constructor for ClassDeclaration used by the parser.
	 *
	 * @param modifiers           The list of modifiers (public, private, static, etc.) for the class.
	 * @param classKeyword        The 'class' keyword token.
	 * @param name                The identifier token for the class name.
	 * @param extendsKeyword      The 'extends' keyword token (can be null if not present).
	 * @param superClassName      The identifier token for the superclass name (can be null if not present).
	 * @param leftBrace           The '{' token opening the class body.
	 * @param fields              List of field declarations within the class.
	 * @param methods             List of method declarations within the class.
	 * @param constructors        List of constructor declarations within the class.
	 * @param rightBrace          The '}' token closing the class body.
	 * @param containingNamespace The fully qualified name of the namespace this class belongs to.
	 */
	public ClassDeclaration(List<Token> modifiers, Token classKeyword, Token name,
							Token extendsKeyword, Token superClassName,
							Token leftBrace, List<FieldDeclaration> fields,
							List<MethodDeclaration> methods, List<ConstructorDeclaration> constructors,
							Token rightBrace, String containingNamespace) // NEW: Added containingNamespace parameter
	{
		this.modifiers = modifiers;
		this.classKeyword = classKeyword;
		this.name = name;
		this.extendsKeyword = extendsKeyword;
		this.superClassName = superClassName;
		this.leftBrace = leftBrace;
		this.rightBrace = rightBrace;
		this.fields = fields;
		this.constructors = constructors;
		this.methods = methods;
		this.containingNamespace = containingNamespace; // NEW: Set the field
	}

	public Token getName()
	{
		return name;
	}

	public Token getExtendsKeyword()
	{
		return extendsKeyword;
	}

	public Token getSuperClassName()
	{
		return superClassName;
	}

	/**
	 * Returns the class name as an IdentifierExpression.
	 * Useful for semantic analysis which expects Expressions for name resolution.
	 */
	public IdentifierExpression getNameExpression()
	{
		return new IdentifierExpression(name);
	}

	public List<Token> getModifiers()
	{
		return Collections.unmodifiableList(modifiers);
	}

	public List<FieldDeclaration> getFields()
	{
		return Collections.unmodifiableList(fields);
	}

	public List<ConstructorDeclaration> getConstructors()
	{
		return Collections.unmodifiableList(constructors);
	}

	public List<MethodDeclaration> getMethods()
	{
		return Collections.unmodifiableList(methods);
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitClassDeclaration(this);
	}

	@Override
	public String toString()
	{
		StringBuilder sb = new StringBuilder();
		modifiers.forEach(mod -> sb.append(mod.getLexeme()).append(" "));
		sb.append("class ").append(name.getLexeme());
		if(superClassName != null)
		{
			sb.append(" extends ").append(superClassName.getLexeme());
		}
		sb.append(" {\n");
		// Append fields
		for(FieldDeclaration field : fields)
		{
			sb.append("    ").append(field.toString().replace("\n", "\n    ")).append("\n");
		}
		// Append constructors
		for(ConstructorDeclaration constructor : constructors)
		{
			sb.append("    ").append(constructor.toString().replace("\n", "\n    ")).append("\n");
		}
		// Append methods
		for(MethodDeclaration method : methods)
		{
			sb.append("    ").append(method.toString().replace("\n", "\n    ")).append("\n");
		}
		sb.append("  }");
		return sb.toString();
	}

	/**
	 * Returns the first token of this ClassDeclaration, which is typically the 'class' keyword.
	 * Useful for error reporting.
	 *
	 * @return The first Token of the class declaration.
	 */
	public Token getFirstToken()
	{
		return classKeyword;
	}

	// NEW: Getter for the containing namespace
	public String getContainingNamespace()
	{
		return containingNamespace;
	}

	// NEW: Setter for the containing namespace (useful for AST building or semantic enrichment)
	public void setContainingNamespace(String containingNamespace)
	{
		this.containingNamespace = containingNamespace;
	}
}

ast/declarations/NamespaceDeclaration.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/declarations/NamespaceDeclaration.java

package com.juanpa.nebula.transpiler.ast.declarations;

import com.juanpa.nebula.transpiler.ast.ASTNode;
import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.ast.expressions.Expression; // Import Expression
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * AST node representing a namespace declaration.
 * Holds the qualified name of the namespace and a list of classes declared within it.
 */
public class NamespaceDeclaration implements ASTNode
{
	private final Expression nameExpression; // Represents the qualified name (e.g., Com.MyCompany.App)
	private final List<ClassDeclaration> classes; // Stores class declarations within this namespace

	/**
	 * Constructor for NamespaceDeclaration.
	 * @param nameExpression The expression representing the qualified name of the namespace.
	 */
	public NamespaceDeclaration(Expression nameExpression)
	{
		this.nameExpression = nameExpression;
		this.classes = new ArrayList<>();
	}

	/**
	 * Returns the expression representing the qualified name of the namespace.
	 * This is used by the SemanticAnalyzer to resolve the full namespace path.
	 * @return The Expression node for the namespace's name.
	 */
	public Expression getNameExpression()
	{
		return nameExpression;
	}

	/**
	 * Returns an unmodifiable list of class declarations within this namespace.
	 * This method name is chosen to be consistent with SemanticAnalyzer's usage.
	 * @return A list of ClassDeclaration AST nodes.
	 */
	public List<ClassDeclaration> getClassDeclarations() // Corrected method name for consistency
	{
		return Collections.unmodifiableList(classes);
	}

	/**
	 * Adds a ClassDeclaration to this namespace.
	 * @param classDecl The ClassDeclaration to add.
	 */
	public void addClass(ClassDeclaration classDecl)
	{
		this.classes.add(classDecl);
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitNamespaceDeclaration(this);
	}

	@Override
	public String toString()
	{
		StringBuilder sb = new StringBuilder();
		sb.append("  Namespace '").append(nameExpression).append("' {\n");
		for (ClassDeclaration classDecl : classes)
		{
			// Indent the class declarations for better readability in AST printout
			sb.append(classDecl.toString().replace("\n", "\n  ")).append("\n");
		}
		sb.append("  }");
		return sb.toString();
	}
}

ast/declarations/ConstructorDeclaration.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/declarations/ConstructorDeclaration.java

package com.juanpa.nebula.transpiler.ast.declarations;

import com.juanpa.nebula.transpiler.ast.ASTNode;
import com.juanpa.nebula.transpiler.ast.ASTVisitor; // Import ASTVisitor
import com.juanpa.nebula.transpiler.ast.statements.BlockStatement;
import com.juanpa.nebula.transpiler.lexer.Token;

import java.util.ArrayList; // Import ArrayList
import java.util.List;
import java.util.stream.Collectors; // Import Collectors

/**
 * AST node representing a constructor declaration.
 * Constructors do not have a return type and their name matches the class name.
 */
public class ConstructorDeclaration implements ASTNode
{
	private final List<Token> modifiers; // e.g., PUBLIC, PRIVATE
	private final Token name;            // The constructor name (should match class name)
	private final List<Token> parameters; // For simplicity, just tokens for now
	private final BlockStatement body;

	public ConstructorDeclaration(List<Token> modifiers, Token name, List<Token> parameters, BlockStatement body)
	{
		this.modifiers = new ArrayList<>(modifiers); // Make a copy
		this.name = name;
		this.parameters = new ArrayList<>(parameters); // Make a copy
		this.body = body;
	}

	public List<Token> getModifiers()
	{
		return modifiers;
	}

	public Token getName()
	{
		return name;
	}

	public List<Token> getParameters()
	{
		return parameters;
	}

	public BlockStatement getBody()
	{
		return body;
	}

	@Override
	public String toString()
	{
		StringBuilder sb = new StringBuilder();
		String mods = modifiers.isEmpty() ? "" : modifiers.stream()
				.map(Token::getLexeme)
				.collect(Collectors.joining(" ")) + " ";
		sb.append(mods).append(name.getLexeme());
		sb.append("(").append(formatParameters(parameters)).append(") {\n");
		sb.append(indent(body.toString(), 1)); // Indent body
		sb.append("}\n");
		return sb.toString();
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor) {
		return visitor.visitConstructorDeclaration(this);
	}

	private String formatParameters(List<Token> params) {
		if (params.isEmpty()) return "";
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < params.size(); i += 2) { // Assuming pairs of (type, name)
			sb.append(params.get(i).getLexeme()).append(" ").append(params.get(i+1).getLexeme());
			if (i + 2 < params.size()) {
				sb.append(", ");
			}
		}
		return sb.toString();
	}

	private String indent(String text, int level) {
		StringBuilder indentedText = new StringBuilder();
		String prefix = "  ".repeat(level);
		for (String line : text.split("\n")) {
			indentedText.append(prefix).append(line).append("\n");
		}
		return indentedText.toString();
	}
}


ast/declarations/ImportDirective.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/ast/declarations/ImportDirective.java
// Changed: File name from UsingDirective.java to ImportDirective.java

package com.juanpa.nebula.transpiler.ast.declarations;

import com.juanpa.nebula.transpiler.ast.ASTNode;
import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.ast.expressions.Expression; // For the qualified name
import com.juanpa.nebula.transpiler.lexer.Token; // For the 'import' token or modifiers
import com.juanpa.nebula.transpiler.lexer.TokenType;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Represents an 'import' directive in Nebula source code.
 * It can be a standard namespace import, a static import,
 * or a global import.
 * Examples:
 * import System.Text;
 * import static System.Console;
 * global import MyNamespace;
 * global static import AnotherType;
 */
public class ImportDirective implements ASTNode
{ // Changed: Class name to ImportDirective
	private final List<Token> modifiers; // Tokens for 'global', 'static'
	private final Expression qualifiedName; // The namespace or type name (e.g., System.Text, System.Console)
	private final Token importKeyword; // Changed: The 'import' keyword token

	public ImportDirective(List<Token> modifiers, Token importKeyword, Expression qualifiedName)
	{ // Changed: Constructor parameter to importKeyword
		this.modifiers = modifiers; // Assume the list is already a copy if needed
		this.importKeyword = importKeyword; // Changed: Assignment
		this.qualifiedName = qualifiedName;
	}

	public List<Token> getModifiers()
	{
		return modifiers;
	}

	public boolean isGlobal()
	{
		return modifiers.stream().anyMatch(m -> m.getType() == TokenType.GLOBAL);
	}

	public boolean isStatic()
	{
		return modifiers.stream().anyMatch(m -> m.getType() == TokenType.STATIC);
	}

	public Expression getQualifiedName()
	{
		return qualifiedName;
	}

	public Token getImportKeyword()
	{ // Changed: Getter to getImportKeyword
		return importKeyword;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitImportDirective(this); // Changed: visitUsingDirective to visitImportDirective
	}

	@Override
	public String toString()
	{
		StringBuilder sb = new StringBuilder();
		if(!modifiers.isEmpty())
		{
			sb.append(modifiers.stream().map(Token::getLexeme).collect(Collectors.joining(" "))).append(" ");
		}
		sb.append("import ").append(qualifiedName.toString()).append(";"); // Changed: "using" to "import"
		return sb.toString();
	}
}

ast/declarations/FieldDeclaration.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/declarations/FieldDeclaration.java
package com.juanpa.nebula.transpiler.ast.declarations;

import com.juanpa.nebula.transpiler.ast.ASTNode;
import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.ast.expressions.Expression;
import com.juanpa.nebula.transpiler.lexer.Token;

import java.util.ArrayList; // Import ArrayList
import java.util.List;
import java.util.stream.Collectors; // Import Collectors

/**
 * Represents a field (member variable) declaration in a class.
 * Example: `public int myField = 10;`
 */
public class FieldDeclaration implements ASTNode
{
	private final List<Token> modifiers; // e.g., public, private, static, const
	private final Token type;            // The type of the field (e.g., int, String, MyCustomClass)
	private final Token name;            // The name of the field
	private final Expression initializer; // The optional initializer expression

	/**
	 * Constructs a new FieldDeclaration.
	 *
	 * @param modifiers   List of modifier tokens for the field.
	 * @param type        The token representing the field's type.
	 * @param name        The token representing the field's name.
	 * @param initializer The optional expression for the field's initial value, can be null.
	 */
	public FieldDeclaration(List<Token> modifiers, Token type, Token name, Expression initializer)
	{
		this.modifiers = new ArrayList<>(modifiers); // Make a copy
		this.type = type;
		this.name = name;
		this.initializer = initializer;
	}

	public List<Token> getModifiers()
	{
		return modifiers;
	}

	public Token getType()
	{
		return type;
	}

	public Token getName()
	{
		return name;
	}

	public Expression getInitializer()
	{
		return initializer;
	}

	@Override
	public String toString()
	{
		StringBuilder sb = new StringBuilder();
		String mods = modifiers.isEmpty() ? "" : modifiers.stream()
				.map(Token::getLexeme)
				.collect(Collectors.joining(" ")) + " ";
		sb.append(mods).append("Field ").append(type.getLexeme()).append(" ").append(name.getLexeme());
		if(initializer != null)
		{
			sb.append(" = ").append(initializer.toString()); // Recursively print initializer
		}
		sb.append(";\n");
		return sb.toString();
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitFieldDeclaration(this);
	}

	private String indent(String text, int level)
	{
		StringBuilder indentedText = new StringBuilder();
		String prefix = "  ".repeat(level);
		for(String line : text.split("\n"))
		{
			indentedText.append(prefix).append(line).append("\n");
		}
		return indentedText.toString();
	}
}

ast/statements/ForStatement.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/statements/ForStatement.java
package com.juanpa.nebula.transpiler.ast.statements;

import com.juanpa.nebula.transpiler.ast.ASTVisitor; // Import ASTVisitor
import com.juanpa.nebula.transpiler.ast.expressions.Expression;

/**
 * AST node representing a 'for' loop statement.
 * Includes an optional initializer, condition, increment expression, and a loop body.
 */
public class ForStatement implements Statement
{
	private final Statement initializer; // Can be a VariableDeclarationStatement or ExpressionStatement (or null)
	private final Expression condition;  // The loop continuation condition (can be null for infinite loop)
	private final Expression increment;  // The expression executed after each iteration (can be null)
	private final BlockStatement body;   // The loop body

	public ForStatement(Statement initializer, Expression condition, Expression increment, BlockStatement body)
	{
		this.initializer = initializer;
		this.condition = condition;
		this.increment = increment;
		this.body = body;
	}

	public Statement getInitializer()
	{
		return initializer;
	}

	public Expression getCondition()
	{
		return condition;
	}

	public Expression getIncrement()
	{
		return increment;
	}

	public BlockStatement getBody()
	{
		return body;
	}

	@Override
	public String toString()
	{
		StringBuilder sb = new StringBuilder("For (");
		sb.append(initializer != null ? initializer.toString().trim() : "");
		sb.append("; ").append(condition != null ? condition.toString() : "");
		sb.append("; ").append(increment != null ? increment.toString() : "");
		sb.append(") {\n");
		sb.append(indent(body.toString(), 1)); // Indent the body
		sb.append("}\n");
		return sb.toString();
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitForStatement(this);
	}

	// Helper for indentation
	private String indent(String text, int level) {
		StringBuilder indentedText = new StringBuilder();
		String prefix = "  ".repeat(level);
		for (String line : text.split("\n")) {
			indentedText.append(prefix).append(line).append("\n");
		}
		return indentedText.toString();
	}
}


ast/statements/VariableDeclarationStatement.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/statements/VariableDeclarationStatement.java

package com.juanpa.nebula.transpiler.ast.statements;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.ast.expressions.Expression;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.lexer.TokenType; // Import TokenType

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

/**
 * AST node representing a variable declaration statement.
 * Includes the type token (e.g., INT, STRING, VAR, or IDENTIFIER for custom types),
 * the variable name, and an optional initializer expression.
 */
public class VariableDeclarationStatement implements Statement
{
	private final List<Token> modifiers; // Add modifiers
	private final Token typeToken;
	private final Token name;
	private final Expression initializer;

	/**
	 * Constructs a VariableDeclarationStatement.
	 *
	 * @param modifiers   List of modifier tokens (e.g., CONST)
	 * @param typeToken   The token representing the declared type.
	 * @param name        The identifier token for the variable name.
	 * @param initializer Optional initializer expression.
	 */
	public VariableDeclarationStatement(List<Token> modifiers, Token typeToken, Token name, Expression initializer)
	{
		this.modifiers = new ArrayList<>(modifiers); // Defensive copy
		this.typeToken = typeToken;
		this.name = name;
		this.initializer = initializer;
	}

	// Existing constructor for backward compatibility (assume no modifiers)
	public VariableDeclarationStatement(Token typeToken, Token name, Expression initializer)
	{
		this(new ArrayList<>(), typeToken, name, initializer);
	}

	public List<Token> getModifiers()
	{ // Getter for modifiers
		return Collections.unmodifiableList(modifiers);
	}

	public Token getTypeToken()
	{
		return typeToken;
	}

	public Token getName()
	{
		return name;
	}

	public Expression getInitializer()
	{
		return initializer;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitVariableDeclarationStatement(this);
	}

	@Override
	public String toString()
	{
		StringBuilder sb = new StringBuilder();
		String mods = modifiers.isEmpty() ? "" : modifiers.stream()
				.map(Token::getLexeme)
				.collect(Collectors.joining(" ")) + " ";
		sb.append("VarDecl: ").append(mods).append(typeToken.getLexeme()).append(" ").append(name.getLexeme());
		if(initializer != null)
		{
			sb.append(" = ").append(initializer);
		}
		return sb.toString();
	}
}

ast/statements/WhileStatement.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/statements/WhileStatement.java
package com.juanpa.nebula.transpiler.ast.statements;

import com.juanpa.nebula.transpiler.ast.ASTVisitor; // Import ASTVisitor
import com.juanpa.nebula.transpiler.ast.expressions.Expression;

/**
 * AST node representing a 'while' loop statement.
 * Includes a condition expression and a loop body.
 */
public class WhileStatement implements Statement
{
	private final Expression condition;
	private final BlockStatement body;

	public WhileStatement(Expression condition, BlockStatement body)
	{
		this.condition = condition;
		this.body = body;
	}

	public Expression getCondition()
	{
		return condition;
	}

	public BlockStatement getBody()
	{
		return body;
	}

	@Override
	public String toString()
	{
		StringBuilder sb = new StringBuilder("While (").append(condition).append(") {\n");
		sb.append(indent(body.toString(), 1)); // Indent the body
		sb.append("}\n");
		return sb.toString();
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitWhileStatement(this);
	}

	// Helper for indentation
	private String indent(String text, int level) {
		StringBuilder indentedText = new StringBuilder();
		String prefix = "  ".repeat(level);
		for (String line : text.split("\n")) {
			indentedText.append(prefix).append(line).append("\n");
		}
		return indentedText.toString();
	}
}


ast/statements/SwitchStatement.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/ast/statements/SwitchStatement.java

package com.juanpa.nebula.transpiler.ast.statements;

import com.juanpa.nebula.transpiler.ast.ASTNode;
import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.ast.expressions.Expression; // The expression being switched on
import com.juanpa.nebula.transpiler.lexer.Token; // Import Token

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors; // Import Collectors

public class SwitchStatement implements Statement
{
	private final Expression switchExpression; // The expression to switch on
	private final List<SwitchCase> cases;    // List of 'case' clauses
	private final BlockStatement defaultBlock; // Optional 'default' block
	private final Token switchKeyword; // The 'switch' keyword token for error reporting

	public SwitchStatement(Token switchKeyword, Expression switchExpression, List<SwitchCase> cases, BlockStatement defaultBlock)
	{
		this.switchKeyword = switchKeyword;
		this.switchExpression = switchExpression;
		this.cases = new ArrayList<>(cases); // Defensive copy
		this.defaultBlock = defaultBlock;
	}

	public Token getSwitchKeyword()
	{
		return switchKeyword;
	}

	public Expression getSwitchExpression()
	{
		return switchExpression;
	}

	public List<SwitchCase> getCases()
	{
		return Collections.unmodifiableList(cases);
	}

	public BlockStatement getDefaultBlock()
	{
		return defaultBlock;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitSwitchStatement(this);
	}

	@Override
	public String toString()
	{
		StringBuilder sb = new StringBuilder("switch (").append(switchExpression.toString()).append(") {\n");
		for(SwitchCase sc : cases)
		{
			sb.append(sc.toString());
		}
		if(defaultBlock != null)
		{
			sb.append("  default:\n").append(defaultBlock.toString()).append("\n");
		}
		sb.append("}\n");
		return sb.toString();
	}
}

ast/statements/SwitchCase.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/ast/statements/SwitchCase.java

package com.juanpa.nebula.transpiler.ast.statements;

import com.juanpa.nebula.transpiler.ast.ASTNode;
import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.ast.expressions.Expression; // The constant value of the case
import com.juanpa.nebula.transpiler.lexer.Token; // Import Token

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors; // Import Collectors

public class SwitchCase implements ASTNode
{
	private final Expression value; // The constant expression for the case (e.g., 10, 'A')
	private final List<Statement> body; // The statements within this case
	private final Token caseKeyword; // The 'case' keyword token for error reporting

	public SwitchCase(Token caseKeyword, Expression value, List<Statement> body)
	{
		this.caseKeyword = caseKeyword;
		this.value = value;
		this.body = new ArrayList<>(body); // Defensive copy
	}

	public Token getCaseKeyword()
	{
		return caseKeyword;
	}

	public Expression getValue()
	{
		return value;
	}

	public List<Statement> getBody()
	{
		return Collections.unmodifiableList(body);
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitSwitchCase(this);
	}

	@Override
	public String toString()
	{
		return "  case " + value.toString() + ":\n" +
				body.stream().map(s -> "    " + s.toString()).collect(Collectors.joining("\n")) + "\n";
	}
}

ast/statements/IfStatement.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/statements/IfStatement.java
package com.juanpa.nebula.transpiler.ast.statements;

import com.juanpa.nebula.transpiler.ast.ASTVisitor; // Import ASTVisitor
import com.juanpa.nebula.transpiler.ast.expressions.Expression;
import com.juanpa.nebula.transpiler.lexer.Token; // Import Token

/**
 * AST node representing an 'if-else' statement.
 * Includes a condition, a 'then' branch (which can be a single statement or a block),
 * and an optional 'else' branch (which can also be a single statement or a block).
 */
public class IfStatement implements Statement
{
	private final Token ifKeyword;       // The 'if' keyword token
	private final Expression condition;
	private final Statement thenBranch;  // CHANGED: From BlockStatement to Statement
	private final Statement elseBranch;  // Already Statement

	/**
	 * Constructs an IfStatement.
	 *
	 * @param ifKeyword  The 'if' keyword token.
	 * @param condition  The expression for the condition.
	 * @param thenBranch The statement or block to execute if the condition is true.
	 * @param elseBranch The optional statement or block to execute if the condition is false.
	 */
	public IfStatement(Token ifKeyword, Expression condition, Statement thenBranch, Statement elseBranch)
	{
		this.ifKeyword = ifKeyword;
		this.condition = condition;
		this.thenBranch = thenBranch;
		this.elseBranch = elseBranch;
	}

	public Token getIfKeyword()
	{
		return ifKeyword;
	}

	public Expression getCondition()
	{
		return condition;
	}

	public Statement getThenBranch() // CHANGED: Return type is Statement
	{
		return thenBranch;
	}

	public Statement getElseBranch()
	{
		return elseBranch;
	}

	@Override
	public String toString()
	{
		StringBuilder sb = new StringBuilder("If (").append(condition).append(") ");

		// For the 'then' branch:
		// If it's a BlockStatement, print it with its curly braces.
		// If it's a single statement, print it directly (its own toString will handle newline).
		// We'll indent the inner content in either case.
		if(thenBranch instanceof BlockStatement)
		{
			sb.append("{\n");
			sb.append(indent(thenBranch.toString(), 1));
			sb.append("}");
		}
		else
		{
			sb.append(indent(thenBranch.toString(), 0).trim()); // Trim to avoid extra newlines if `statement().toString()` adds one
		}


		if(elseBranch != null)
		{
			sb.append(" Else ");
			// For the 'else' branch:
			if(elseBranch instanceof BlockStatement)
			{
				sb.append("{\n");
				sb.append(indent(elseBranch.toString(), 1));
				sb.append("}");
			}
			else
			{
				sb.append(indent(elseBranch.toString(), 0).trim());
			}
		}
		sb.append("\n"); // Ensure a consistent newline at the end of the entire if statement
		return sb.toString();
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitIfStatement(this);
	}

	// Helper for indentation
	private String indent(String text, int level)
	{
		StringBuilder indentedText = new StringBuilder();
		String prefix = "  ".repeat(level);
		// Split by any Unicode newline sequence to handle different OS line endings
		String[] lines = text.split("\\R");
		for(int i = 0; i < lines.length; i++)
		{
			if(!lines[i].trim().isEmpty())
			{ // Only indent non-empty lines
				indentedText.append(prefix).append(lines[i]);
			}
			else
			{
				indentedText.append(lines[i]); // Keep empty lines as is
			}
			if(i < lines.length - 1)
			{
				indentedText.append("\n"); // Add newline back for all but the last line
			}
		}
		return indentedText.toString();
	}

	public Token getFirstToken()
	{
		return ifKeyword; // The 'if' keyword is the first token of the IfStatement
	}
}
ast/statements/ConstructorChainingCallStatement.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/ast/statements/ConstructorChainingCallStatement.java

package com.juanpa.nebula.transpiler.ast.statements;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.ast.expressions.Expression;
import com.juanpa.nebula.transpiler.lexer.Token;

import java.util.Collections;
import java.util.List;

/**
 * AST node representing a constructor chaining call within a constructor (e.g., `this(...)` or `super(...)`).
 * This is a statement, not an expression.
 */
public class ConstructorChainingCallStatement implements Statement
{
	private final Token keyword; // The 'this' or 'super' keyword
	private final Token leftParen; // The opening parenthesis token
	private final List<Expression> arguments;
	private final Token rightParen; // The closing parenthesis token

	public ConstructorChainingCallStatement(Token keyword, Token leftParen, List<Expression> arguments, Token rightParen)
	{
		this.keyword = keyword;
		this.leftParen = leftParen;
		this.arguments = arguments;
		this.rightParen = rightParen;
	}

	public Token getKeyword()
	{
		return keyword;
	}

	public List<Expression> getArguments()
	{
		return Collections.unmodifiableList(arguments);
	}

	public Token getFirstToken()
	{
		return keyword;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitConstructorChainingCallStatement(this);
	}

	@Override
	public String toString()
	{
		StringBuilder sb = new StringBuilder();
		sb.append(keyword.getLexeme()).append("(");
		for(int i = 0; i < arguments.size(); i++)
		{
			sb.append(arguments.get(i).toString());
			if(i < arguments.size() - 1)
			{
				sb.append(", ");
			}
		}
		sb.append(");");
		return sb.toString();
	}
}
ast/statements/Statement.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/statements/Statement.java
package com.juanpa.nebula.transpiler.ast.statements;

import com.juanpa.nebula.transpiler.ast.ASTNode;

/**
 * Base interface for all statement nodes in the Abstract Syntax Tree.
 * Statements are units of execution that do not necessarily produce a value.
 */
public interface Statement extends ASTNode
{
	// No common methods yet, but can be added later.
}


ast/statements/ReturnStatement.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/statements/ReturnStatement.java
package com.juanpa.nebula.transpiler.ast.statements;

import com.juanpa.nebula.transpiler.ast.ASTVisitor; // Import ASTVisitor
import com.juanpa.nebula.transpiler.ast.expressions.Expression;
import com.juanpa.nebula.transpiler.lexer.Token;

/**
 * AST node representing a return statement.
 * Can optionally include an expression to be returned.
 */
public class ReturnStatement implements Statement
{
	private final Token keyword; // The 'return' keyword token
	private final Expression value; // Optional expression to return

	public ReturnStatement(Token keyword, Expression value)
	{
		this.keyword = keyword;
		this.value = value;
	}

	public Token getKeyword()
	{
		return keyword;
	}

	public Expression getValue()
	{
		return value;
	}

	@Override
	public String toString()
	{
		String val = value != null ? " " + value.toString() : "";
		return "Return" + val + ";\n";
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitReturnStatement(this);
	}
}


ast/statements/ExpressionStatement.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/statements/ExpressionStatement.java
package com.juanpa.nebula.transpiler.ast.statements;

import com.juanpa.nebula.transpiler.ast.ASTVisitor; // Import ASTVisitor
import com.juanpa.nebula.transpiler.ast.expressions.Expression;

/**
 * AST node representing a statement that consists solely of an expression,
 * typically followed by a semicolon (e.g., `someMethodCall();`).
 */
public class ExpressionStatement implements Statement
{
	private final Expression expression;

	public ExpressionStatement(Expression expression)
	{
		this.expression = expression;
	}

	public Expression getExpression()
	{
		return expression;
	}

	@Override
	public String toString()
	{
		return "ExprStmt: " + expression + ";\n";
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitExpressionStatement(this);
	}
}


ast/statements/BlockStatement.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/statements/BlockStatement.java
package com.juanpa.nebula.transpiler.ast.statements;

import com.juanpa.nebula.transpiler.ast.ASTNode;
import com.juanpa.nebula.transpiler.ast.ASTVisitor;

import java.util.ArrayList;
import java.util.List;

/**
 * AST node representing a block of statements enclosed in curly braces {}.
 * This is used for method bodies, if/else blocks, loop bodies, etc.
 */
public class BlockStatement implements Statement
{
	private final List<Statement> statements;

	public BlockStatement()
	{
		this.statements = new ArrayList<>();
	}

	/**
	 * Constructor to create a BlockStatement from a pre-existing list of statements.
	 *
	 * @param statements The list of statements to include in this block.
	 */
	public BlockStatement(List<Statement> statements)
	{
		this.statements = new ArrayList<>(statements); // Defensive copy
	}


	public void addStatement(Statement statement)
	{
		this.statements.add(statement);
	}

	public List<Statement> getStatements()
	{
		return statements;
	}

	@Override
	public String toString()
	{
		StringBuilder sb = new StringBuilder("{\n");
		for(Statement stmt : statements)
		{
			// Indent statements within the block
			sb.append(indent(stmt.toString(), 1));
		}
		sb.append("}");
		return sb.toString();
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitBlockStatement(this);
	}

	// Helper for indentation
	private String indent(String text, int level)
	{
		StringBuilder indentedText = new StringBuilder();
		String prefix = "  ".repeat(level);
		for(String line : text.split("\n"))
		{
			indentedText.append(prefix).append(line).append("\n");
		}
		return indentedText.toString();
	}
}

--- End of Listing ---
