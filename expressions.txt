--- Directory Tree for: expressions ---
Located at: /home/juanpa/dev/java/nebula/transpiler/src/main/java/com/juanpa/nebula/transpiler/ast/expressions

/home/juanpa/dev/java/nebula/transpiler/src/main/java/com/juanpa/nebula/transpiler/ast/expressions
├── ArrayAccessExpression.java
├── AssignmentExpression.java
├── BinaryExpression.java
├── CallExpression.java
├── DotExpression.java
├── Expression.java
├── GroupingExpression.java
├── IdentifierExpression.java
├── IsExpression.java
├── LiteralExpression.java
├── NewExpression.java
├── PostfixUnaryExpression.java
├── ThisExpression.java
└── UnaryExpression.java

1 directory, 14 files

--- File Contents (Recursive) ---
CallExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/expressions/CallExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * AST node representing a function or method call.
 * Includes the expression representing the callable entity (e.g., identifier, dot expression)
 * and a list of argument expressions.
 */
public class CallExpression implements Expression
{
	private final Expression callee; // The expression being called (e.g., IdentifierExpression, DotExpression)
	private final Token paren;       // The opening parenthesis token (for error reporting)
	private final List<Expression> arguments;

	public CallExpression(Expression callee, Token paren, List<Expression> arguments)
	{
		this.callee = callee;
		this.paren = paren;
		this.arguments = new ArrayList<>(arguments); // Defensive copy
	}

	public Expression getCallee()
	{
		return callee;
	}

	public Token getParen()
	{
		return paren;
	}

	public List<Expression> getArguments()
	{
		return Collections.unmodifiableList(arguments);
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitCallExpression(this);
	}

	@Override
	public String toString()
	{
		StringBuilder sb = new StringBuilder();
		sb.append("(").append(callee);
		sb.append(")"); // Closing parenthesis from parser
		sb.append("("); // Opening parenthesis for arguments
		for(int i = 0; i < arguments.size(); i++)
		{
			sb.append(arguments.get(i));
			if(i < arguments.size() - 1)
			{
				sb.append(", ");
			}
		}
		sb.append(")"); // Closing parenthesis for arguments
		return sb.toString();
	}

	@Override
	public Token getFirstToken()
	{
		return callee.getFirstToken(); // The first token is the first token of the callee expression
	}
}
UnaryExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/expressions/UnaryExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;

/**
 * AST node representing a unary operation (e.g., !a, -b).
 * It has an operator token and a single operand expression.
 */
public class UnaryExpression implements Expression
{
	private final Token operator; // The unary operator token (e.g., BANG, MINUS)
	private final Expression right; // The operand expression

	public UnaryExpression(Token operator, Expression right)
	{
		this.operator = operator;
		this.right = right;
	}

	public Token getOperator()
	{
		return operator;
	}

	public Expression getRight()
	{
		return right;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitUnaryExpression(this);
	}

	@Override
	public String toString()
	{
		return "(" + operator.getLexeme() + right + ")";
	}

	@Override
	public Token getFirstToken()
	{
		return operator; // The first token of a unary expression is its operator
	}
}
LiteralExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/expressions/LiteralExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.lexer.TokenType;

/**
 * AST node representing a literal value (e.g., 123, "hello", true, 3.14).
 * Holds the literal value and its corresponding token.
 */
public class LiteralExpression implements Expression
{
	private final Object value; // The actual literal value (e.g., Integer, String, Boolean, Double)
	private final Token literalToken; // The token representing the literal

	public LiteralExpression(Object value, Token literalToken)
	{
		this.value = value;
		this.literalToken = literalToken;
	}

	public Object getValue()
	{
		return value;
	}

	public Token getLiteralToken()
	{
		return literalToken;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitLiteralExpression(this);
	}

	@Override
	public String toString()
	{
		// For string literals, include quotes in the output for clarity
		if(literalToken.getType() == TokenType.STRING_LITERAL)
		{
			return "\"" + value + "\"";
		}
		return value.toString();
	}

	@Override
	public Token getFirstToken()
	{
		return literalToken;
	}
}
NewExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/ast/expressions/NewExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.lexer.TokenType;
import com.juanpa.nebula.transpiler.semantics.MethodSymbol; // Import MethodSymbol

import java.util.Collections;
import java.util.List;

/**
 * AST node representing an object instantiation expression (e.g., `new MyClass(arg1, arg2)`).
 */
public class NewExpression implements Expression
{
	private final Token newKeyword; // The 'new' keyword token
	private final Expression className; // The class name being instantiated (IdentifierExpression or DotExpression)
	private final Token paren; // The opening parenthesis token for argument list
	private final List<Expression> arguments; // List of arguments passed to the constructor
	private MethodSymbol resolvedConstructor; // Added to store the resolved constructor symbol

	public NewExpression(Token newKeyword, Expression className, Token paren, List<Expression> arguments)
	{
		if(newKeyword.getType() != TokenType.NEW)
		{
			throw new IllegalArgumentException("Token for NewExpression must be 'new'.");
		}
		if(paren.getType() != TokenType.LEFT_PAREN)
		{
			throw new IllegalArgumentException("Token for NewExpression's parenthesis must be '('.");
		}
		this.newKeyword = newKeyword;
		this.className = className;
		this.paren = paren;
		this.arguments = Collections.unmodifiableList(arguments);
	}

	public Token getNewKeyword()
	{
		return newKeyword;
	}

	public Expression getClassName()
	{
		return className;
	}

	public Token getParen()
	{
		return paren;
	}

	public List<Expression> getArguments()
	{
		return arguments;
	}

	// Getter for resolved constructor
	public MethodSymbol getResolvedConstructor()
	{
		return resolvedConstructor;
	}

	// Setter for resolved constructor
	public void setResolvedConstructor(MethodSymbol resolvedConstructor)
	{
		this.resolvedConstructor = resolvedConstructor;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitNewExpression(this);
	}

	@Override
	public String toString()
	{
		StringBuilder sb = new StringBuilder();
		sb.append(newKeyword.getLexeme()).append(" ");
		sb.append(className.toString());
		sb.append("(");
		for(int i = 0; i < arguments.size(); i++)
		{
			sb.append(arguments.get(i).toString());
			if(i < arguments.size() - 1)
			{
				sb.append(", ");
			}
		}
		sb.append(")");
		return sb.toString();
	}

	@Override
	public Token getFirstToken()
	{
		return newKeyword;
	}
}

DotExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/expressions/DotExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.semantics.Symbol; // Import Symbol

/**
 * AST node representing a member access expression (e.g., object.property, Namespace.Class.staticMethod).
 * It has a left-hand side expression (the object/namespace) and an identifier for the member.
 */
public class DotExpression implements Expression
{
	private final Expression left; // The left-hand side (e.g., IdentifierExpression for object, DotExpression for qualified name)
	private final Token dotToken; // The dot operator token
	private final Token memberName; // The identifier token for the member name (field, method, nested class)

	// Semantic information to be filled during semantic analysis
	private Symbol resolvedSymbol;

	public DotExpression(Expression left, Token dotToken, Token memberName)
	{
		this.left = left;
		this.dotToken = dotToken;
		this.memberName = memberName;
	}

	public Expression getLeft()
	{
		return left;
	}

	public Token getDotToken()
	{
		return dotToken;
	}

	public Token getMemberName()
	{
		return memberName;
	}

	public Symbol getResolvedSymbol()
	{
		return resolvedSymbol;
	}

	public void setResolvedSymbol(Symbol resolvedSymbol)
	{
		this.resolvedSymbol = resolvedSymbol;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitDotExpression(this);
	}

	@Override
	public String toString()
	{
		// Example: ((Com.MyCompany).App) or (obj.field)
		return "(" + left + "." + memberName.getLexeme() + ")";
	}

	@Override
	public Token getFirstToken()
	{
		return left.getFirstToken(); // The first token is the first token of the left expression
	}
}

BinaryExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/expressions/BinaryExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;

/**
 * AST node representing a binary operation (e.g., a + b, x == y, c && d).
 * It has a left operand, an operator token, and a right operand.
 */
public class BinaryExpression implements Expression {
	private final Expression left;
	private final Token operator; // The binary operator token (e.g., PLUS, MINUS, EQUAL_EQUAL)
	private final Expression right;

	public BinaryExpression(Expression left, Token operator, Expression right) {
		this.left = left;
		this.operator = operator;
		this.right = right;
	}

	public Expression getLeft() {
		return left;
	}

	public Token getOperator() {
		return operator;
	}

	public Expression getRight() {
		return right;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor) {
		return visitor.visitBinaryExpression(this);
	}

	@Override
	public String toString() {
		return "(" + left + " " + operator.getLexeme() + " " + right + ")";
	}

	@Override
	public Token getFirstToken() {
		return left.getFirstToken(); // The first token of a binary expression is its left operand's first token
	}
}
IdentifierExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/expressions/IdentifierExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.lexer.TokenType;
import com.juanpa.nebula.transpiler.semantics.Symbol; // Import Symbol

/**
 * AST node representing an identifier (e.g., a variable name, class name, method name).
 */
public class IdentifierExpression implements Expression
{
	private final Token name; // The IDENTIFIER token
	private Symbol resolvedSymbol; // Added field for resolved symbol

	public IdentifierExpression(Token name)
	{
		if(name.getType() != TokenType.IDENTIFIER)
		{
			throw new IllegalArgumentException("Token for IdentifierExpression must be an IDENTIFIER.");
		}
		this.name = name;
	}

	public Token getName()
	{
		return name;
	}

	// Getter for resolved symbol
	public Symbol getResolvedSymbol()
	{
		return resolvedSymbol;
	}

	// Setter for resolved symbol
	public void setResolvedSymbol(Symbol resolvedSymbol)
	{
		this.resolvedSymbol = resolvedSymbol;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitIdentifierExpression(this);
	}

	@Override
	public String toString()
	{
		return name.getLexeme();
	}

	@Override
	public Token getFirstToken()
	{
		return name;
	}
}
Expression.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/expressions/Expression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTNode;
import com.juanpa.nebula.transpiler.lexer.Token;

/**
 * Base interface for all expression nodes in the Abstract Syntax Tree (AST).
 * Expressions are parts of the program that produce a value.
 */
public interface Expression extends ASTNode
{
	/**
	 * Returns the first token that constitutes this expression.
	 * Useful for error reporting to pinpoint the exact location of a semantic error.
	 *
	 * @return The first Token of this expression.
	 */
	Token getFirstToken();
}
IsExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/ast/expressions/IsExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;

/**
 * AST node for the 'is' type-checking operator (e.g., `expr is Type`).
 */
public class IsExpression implements Expression
{
	private final Expression left;
	private final Token isKeyword; // The 'is' keyword token
	private final Token typeToken; // The token representing the type (e.g., IDENTIFIER for class, or primitive keyword)

	public IsExpression(Expression left, Token isKeyword, Token typeToken)
	{
		this.left = left;
		this.isKeyword = isKeyword;
		this.typeToken = typeToken;
	}

	public Expression getLeft()
	{
		return left;
	}

	public Token getIsKeyword()
	{
		return isKeyword;
	}

	public Token getTypeToken()
	{
		return typeToken;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		// This will call visitor.visitIsExpression(this)
		return visitor.visitIsExpression(this);
	}

	@Override
	public Token getFirstToken()
	{
		return left.getFirstToken();
	}

	@Override
	public String toString()
	{
		return "(" + left.toString() + " is " + typeToken.getLexeme() + ")";
	}
}
GroupingExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/ast/expressions/GroupingExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.lexer.TokenType;

/**
 * AST node representing a grouped expression, enclosed in parentheses (e.g., `(a + b)`).
 * This node is primarily used to enforce operator precedence.
 */
public class GroupingExpression implements Expression
{
	private final Expression expression; // The inner expression being grouped
	private final Token leftParen;      // The opening parenthesis token

	/**
	 * Constructs a new GroupingExpression.
	 *
	 * @param leftParen  The opening parenthesis token.
	 * @param expression The inner expression enclosed by the parentheses.
	 */
	public GroupingExpression(Token leftParen, Expression expression)
	{
		if(leftParen.getType() != TokenType.LEFT_PAREN)
		{
			throw new IllegalArgumentException("Token for GroupingExpression must be TokenType.LEFT_PAREN.");
		}
		this.leftParen = leftParen;
		this.expression = expression;
	}

	public Expression getExpression()
	{
		return expression;
	}

	public Token getLeftParen()
	{
		return leftParen;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitGroupingExpression(this);
	}

	@Override
	public String toString()
	{
		return "(" + expression.toString() + ")";
	}

	@Override
	public Token getFirstToken()
	{
		return leftParen; // The opening parenthesis is the first token of the grouping expression
	}
}

ArrayAccessExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa/nebula/transpiler/ast/expressions/ArrayAccessExpression.java
package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;

// Corrected to implement the Expression interface
public class ArrayAccessExpression implements Expression
{
	private final Expression array; // The expression representing the array/string
	private final Expression index; // The expression representing the index
	private final Token rightBracket; // The ']' token

	public ArrayAccessExpression(Expression array, Expression index, Token rightBracket)
	{
		// No super() call needed as Expression is an interface
		this.array = array;
		this.index = index;
		this.rightBracket = rightBracket;
	}

	public Expression getArray()
	{
		return array;
	}

	public Expression getIndex()
	{
		return index;
	}

	public Token getRightBracket()
	{
		return rightBracket;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitArrayAccessExpression(this);
	}

	@Override
	public Token getFirstToken()
	{
		// The first token of an ArrayAccessExpression is the first token of the array expression
		return array.getFirstToken();
	}
}
PostfixUnaryExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/expressions/PostfixUnaryExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;

/**
 * AST node representing a postfix unary operation (e.g., x++, y--).
 * It has an operand expression and a postfix operator token.
 */
public class PostfixUnaryExpression implements Expression
{
	private final Expression operand; // The expression being operated on (must be assignable)
	private final Token operator;    // The postfix operator token (e.g., PLUS_PLUS, MINUS_MINUS)

	public PostfixUnaryExpression(Expression operand, Token operator)
	{
		this.operand = operand;
		this.operator = operator;
	}

	public Expression getOperand()
	{
		return operand;
	}

	public Token getOperator()
	{
		return operator;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitPostfixUnaryExpression(this);
	}

	@Override
	public String toString()
	{
		return "(" + operand + operator.getLexeme() + ")";
	}

	@Override
	public Token getFirstToken()
	{
		return operand.getFirstToken(); // The first token is the first token of the operand
	}
}
ThisExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/expressions/ThisExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.lexer.TokenType;
import com.juanpa.nebula.transpiler.semantics.Symbol; // Import Symbol

/**
 * AST node representing the 'this' keyword.
 * Represents a reference to the current instance of the class.
 */
public class ThisExpression implements Expression
{
	private final Token keyword; // The 'this' keyword token
	private Symbol resolvedSymbol; // NEW: Added field for resolved symbol

	public ThisExpression(Token keyword)
	{
		if(keyword.getType() != TokenType.THIS)
		{
			throw new IllegalArgumentException("Keyword for ThisExpression must be TokenType.THIS.");
		}
		this.keyword = keyword;
	}

	public Token getKeyword()
	{
		return keyword;
	}

	// NEW: Getter for resolved symbol
	public Symbol getResolvedSymbol()
	{
		return resolvedSymbol;
	}

	// NEW: Setter for resolved symbol
	public void setResolvedSymbol(Symbol resolvedSymbol)
	{
		this.resolvedSymbol = resolvedSymbol;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitThisExpression(this);
	}

	@Override
	public String toString()
	{
		return "this";
	}

	@Override
	public Token getFirstToken()
	{
		return keyword; // The 'this' keyword itself is the first token
	}
}

AssignmentExpression.java:
[AND the contents]
// File: src/main/java/com/juanpa.nebula.transpiler/ast/expressions/AssignmentExpression.java

package com.juanpa.nebula.transpiler.ast.expressions;

import com.juanpa.nebula.transpiler.ast.ASTVisitor;
import com.juanpa.nebula.transpiler.lexer.Token;
import com.juanpa.nebula.transpiler.lexer.TokenType;

/**
 * AST node representing an assignment operation (e.g., x = 10, obj.property = value, x += 5).
 * It holds the target expression (what's being assigned to), the operator, and the value expression.
 */
public class AssignmentExpression implements Expression
{
	private final Expression target; // The left-hand side of the assignment (e.g., IdentifierExpression, DotExpression)
	private final Token operator;    // The assignment operator token (e.g., ASSIGN, PLUS_ASSIGN, MINUS_ASSIGN)
	private final Expression value;  // The right-hand side expression

	/**
	 * Constructor for AssignmentExpression.
	 *
	 * @param target   The expression representing the target of the assignment.
	 * @param operator The assignment operator token.
	 * @param value    The expression whose value is being assigned.
	 */
	public AssignmentExpression(Expression target, Token operator, Expression value)
	{
		// Basic validation for the operator type (can be expanded)
		if(!isAssignmentOperator(operator.getType()))
		{
			throw new IllegalArgumentException("Invalid token type for assignment operator: " + operator.getType());
		}
		this.target = target;
		this.operator = operator;
		this.value = value;
	}

	private boolean isAssignmentOperator(TokenType type)
	{
		return type == TokenType.ASSIGN || type == TokenType.PLUS_ASSIGN ||
				type == TokenType.MINUS_ASSIGN || type == TokenType.STAR_ASSIGN ||
				type == TokenType.SLASH_ASSIGN || type == TokenType.MODULO_ASSIGN;
	}

	public Expression getTarget()
	{
		return target;
	}

	public Token getOperator()
	{
		return operator;
	}

	public Expression getValue()
	{
		return value;
	}

	@Override
	public <R> R accept(ASTVisitor<R> visitor)
	{
		return visitor.visitAssignmentExpression(this);
	}

	@Override
	public String toString()
	{
		return "(" + target + " " + operator.getLexeme() + " " + value + ")";
	}

	@Override
	public Token getFirstToken()
	{
		return target.getFirstToken(); // The first token is the first token of the target expression
	}
}
--- End of Listing ---
